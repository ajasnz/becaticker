#!/usr/bin/env python3
"""
BecaTicker - LED Matrix Display Controller

A dual-chain RGB LED matrix display system featuring:
- Chain 1: 4x1 horizontal panels (256x64) for text display
- Chain 2: 2x2 square panels (128x128) for analog clock and arcade games

Author: Generated by GitHub Copilot
Date: September 30, 2025
"""

import argparse
import json
import logging
import math
import os
import subprocess
import sys
import threading
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple

import requests
from dateutil import parser as date_parser
from flask import Flask, jsonify, render_template, request
from icalendar import Calendar
from PIL import Image, ImageDraw, ImageFont

# Add the RGB matrix library path
sys.path.append(
    os.path.join(os.path.dirname(__file__), "hzeller", "bindings", "python")
)

try:
    from rgbmatrix import RGBMatrix, RGBMatrixOptions, graphics
except ImportError as e:
    logger.error(f"Failed to import RGB matrix library: {e}")
    logger.error("Please ensure the RGB matrix library is properly installed.")
    logger.error("Run './build_rgb_matrix.sh' to build the library.")
    sys.exit(1)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler("becaticker.log"), logging.StreamHandler(sys.stdout)],
)
logger = logging.getLogger(__name__)


class Config:
    """Configuration manager for BecaTicker."""

    def __init__(self, config_file: str = "config.json"):
        self.config_file = config_file
        self.default_config = {
            "department_name": "PLATFORM 38 1/2",
            "scrolling_messages": [
                "Safe System Assessments",
                "TIAs",
                "ITS",
                "Public Transport",
                "Parking, Walking & Cycling",
            ],
            "calendar_urls": ["https://www.officeholidays.com/ics-all/new-zealand"],
            "web_port": 5000,
            "matrix_options": {
                "chain1": {
                    "rows": 64,
                    "cols": 128,
                    "chain_length": 2,
                    "parallel": 1,
                    "brightness": 75,
                    "gpio_mapping": "regular",
                },
                "chain2": {
                    "rows": 64,
                    "cols": 64,
                    "chain_length": 4,
                    "parallel": 1,
                    "brightness": 75,
                    "gpio_mapping": "regular",
                },
            },
            "display_settings": {
                "text_color": [255, 255, 255],
                "clock_color": [0, 255, 0],
                "background_color": [0, 0, 0],
                "scroll_speed": 0.05,
                "calendar_refresh_minutes": 30,
            },
            "arcade_mode": {
                "enabled": True,
                "trigger_command": "/usr/bin/emulationstation",
            },
        }
        self.config = self.load_config()

    def load_config(self) -> Dict:
        """Load configuration from file or create with defaults."""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, "r") as f:
                    config = json.load(f)
                # Merge with defaults to ensure all keys exist
                return {**self.default_config, **config}
            else:
                self.save_config(self.default_config)
                return self.default_config.copy()
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            return self.default_config.copy()

    def save_config(self, config: Dict = None) -> None:
        """Save configuration to file."""
        try:
            config_to_save = config or self.config
            with open(self.config_file, "w") as f:
                json.dump(config_to_save, f, indent=2)
            logger.info("Configuration saved successfully")
        except Exception as e:
            logger.error(f"Error saving config: {e}")

    def get(self, key: str, default=None):
        """Get configuration value."""
        keys = key.split(".")
        value = self.config
        for k in keys:
            value = value.get(k, {})
        return value if value != {} else default

    def set(self, key: str, value) -> None:
        """Set configuration value."""
        keys = key.split(".")
        config = self.config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value
        self.save_config()


class CalendarManager:
    """Manages calendar events from ICS feeds."""

    def __init__(self, config: Config):
        self.config = config
        self.events: List[Dict] = []
        self.last_update = datetime.min

    def fetch_events(self) -> List[Dict]:
        """Fetch and parse calendar events from ICS URLs."""
        calendar_urls = self.config.get("calendar_urls", [])
        if not calendar_urls:
            return []

        refresh_minutes = self.config.get(
            "display_settings.calendar_refresh_minutes", 30
        )
        if datetime.now() - self.last_update < timedelta(minutes=refresh_minutes):
            return self.events

        all_events = []

        for url in calendar_urls:
            try:
                logger.info(f"Fetching calendar from: {url}")
                response = requests.get(url, timeout=10)
                response.raise_for_status()

                cal = Calendar.from_ical(response.content)

                for component in cal.walk():
                    if component.name == "VEVENT":
                        event = {
                            "summary": str(component.get("summary", "No Title")),
                            "start": component.get("dtstart").dt,
                            "end": (
                                component.get("dtend").dt
                                if component.get("dtend")
                                else None
                            ),
                            "description": str(component.get("description", "")),
                        }

                        # Only include future events within next 7 days
                        if isinstance(event["start"], datetime):
                            start_time = event["start"]
                        else:
                            # Handle date-only events
                            start_time = datetime.combine(
                                event["start"], datetime.min.time()
                            )

                        now = datetime.now()
                        if start_time > now and start_time < now + timedelta(days=7):
                            all_events.append(event)

            except Exception as e:
                logger.error(f"Error fetching calendar from {url}: {e}")

        # Sort events by start time
        all_events.sort(key=lambda x: x["start"])
        self.events = all_events[:10]  # Keep only next 10 events
        self.last_update = datetime.now()

        logger.info(f"Updated calendar with {len(self.events)} events")
        return self.events


class TextDisplay:
    """Handles text display on Chain 1 (4x1 horizontal panels)."""

    def __init__(
        self, matrix: RGBMatrix, config: Config, calendar_manager: CalendarManager
    ):
        self.matrix = matrix
        self.config = config
        self.calendar_manager = calendar_manager
        self.canvas = matrix.CreateFrameCanvas()

        # Load fonts
        self.title_font = graphics.Font()
        self.title_font.LoadFont(os.path.join("hzeller", "fonts", "9x15B.bdf"))

        self.text_font = graphics.Font()
        self.text_font.LoadFont(os.path.join("hzeller", "fonts", "7x13.bdf"))

        self.small_font = graphics.Font()
        self.small_font.LoadFont(os.path.join("hzeller", "fonts", "6x10.bdf"))

        # Colors
        text_color = self.config.get("display_settings.text_color", [255, 255, 255])
        self.text_color = graphics.Color(*text_color)
        self.title_color = graphics.Color(255, 255, 0)  # Yellow for title
        self.event_color = graphics.Color(0, 255, 255)  # Cyan for events

        # Scrolling state
        self.scroll_pos = 0
        self.current_message_index = 0
        self.message_change_time = time.time()

    def update_display(self) -> None:
        """Update the text display with current information."""
        self.canvas.Clear()

        # Row 1: Department name (static, centered)
        dept_name = self.config.get("department_name", "DEPARTMENT")
        self._draw_centered_text(dept_name, self.title_font, self.title_color, 12)

        # Row 2: Scrolling messages
        self._draw_scrolling_message(32)

        # Row 3: Calendar events
        self._draw_calendar_events(52)

        # Swap buffers
        self.canvas = self.matrix.SwapOnVSync(self.canvas)

    def _draw_centered_text(
        self, text: str, font: graphics.Font, color: graphics.Color, y: int
    ) -> None:
        """Draw centered text at specified y position."""
        text_width = sum([font.CharacterWidth(ord(c)) for c in text])
        x = (self.canvas.width - text_width) // 2
        graphics.DrawText(self.canvas, font, x, y, color, text)

    def _draw_scrolling_message(self, y: int) -> None:
        """Draw scrolling message at specified y position."""
        messages = self.config.get("scrolling_messages", ["No messages configured"])
        if not messages:
            return

        # Change message every 10 seconds
        if time.time() - self.message_change_time > 10:
            self.current_message_index = (self.current_message_index + 1) % len(
                messages
            )
            self.message_change_time = time.time()
            self.scroll_pos = self.canvas.width

        current_message = messages[self.current_message_index]

        # Draw scrolling text
        text_len = graphics.DrawText(
            self.canvas,
            self.text_font,
            self.scroll_pos,
            y,
            self.text_color,
            current_message,
        )

        # Update scroll position
        scroll_speed = self.config.get("display_settings.scroll_speed", 0.05)
        self.scroll_pos -= 1

        # Reset scroll when text completely off screen
        if self.scroll_pos + text_len < 0:
            self.scroll_pos = self.canvas.width

    def _draw_calendar_events(self, y: int) -> None:
        """Draw upcoming calendar events."""
        events = self.calendar_manager.fetch_events()
        if not events:
            graphics.DrawText(
                self.canvas,
                self.small_font,
                2,
                y,
                self.event_color,
                "No upcoming events",
            )
            return

        # Show first 2 events that fit
        x_offset = 2
        for i, event in enumerate(events[:2]):
            if i > 0:
                x_offset += 128  # Move to next panel area

            # Format event text
            if isinstance(event["start"], datetime):
                start_str = event["start"].strftime("%m/%d %H:%M")
            else:
                start_str = event["start"].strftime("%m/%d")

            event_text = f"{start_str}: {event['summary'][:20]}"
            graphics.DrawText(
                self.canvas, self.small_font, x_offset, y, self.event_color, event_text
            )


class ClockDisplay:
    """Handles analog clock display on Chain 2 (2x2 square panels)."""

    def __init__(self, matrix: RGBMatrix, config: Config):
        self.matrix = matrix
        self.config = config
        self.canvas = matrix.CreateFrameCanvas()

        # Clock settings
        clock_color = self.config.get("display_settings.clock_color", [0, 255, 0])
        self.clock_color = graphics.Color(*clock_color)
        self.center_x = 64  # Center of 128x128 display
        self.center_y = 64
        self.radius = 60

        # Arcade mode
        self.arcade_mode = False
        self.arcade_process = None

    def update_display(self) -> None:
        """Update the analog clock display or show arcade mode."""
        if self.arcade_mode:
            # In arcade mode, the display is handled by the game system
            # Just keep the matrix clear for the game to use
            self.canvas.Clear()
            self.canvas = self.matrix.SwapOnVSync(self.canvas)
            return

        self.canvas.Clear()

        now = datetime.now()

        # Draw clock face
        self._draw_clock_face()

        # Calculate angles (12 o'clock = 0°, clockwise)
        hour_angle = ((now.hour % 12) + now.minute / 60.0) * 30 - 90  # 30° per hour
        minute_angle = now.minute * 6 - 90  # 6° per minute
        second_angle = now.second * 6 - 90  # 6° per second

        # Draw hands
        self._draw_hand(hour_angle, self.radius * 0.5, 3)  # Hour hand
        self._draw_hand(minute_angle, self.radius * 0.8, 2)  # Minute hand
        self._draw_hand(second_angle, self.radius * 0.9, 1)  # Second hand

        # Draw center dot
        self.canvas.SetPixel(self.center_x, self.center_y, 255, 255, 255)

        # Swap buffers
        self.canvas = self.matrix.SwapOnVSync(self.canvas)

    def enter_arcade_mode(self) -> bool:
        """Enter arcade mode and launch RetroPie."""
        if self.arcade_mode:
            return True

        try:
            import subprocess

            trigger_command = self.config.get(
                "arcade_mode.trigger_command", "/usr/bin/emulationstation"
            )

            logger.info(f"Launching arcade mode: {trigger_command}")

            # Launch RetroPie/EmulationStation
            self.arcade_process = subprocess.Popen(
                trigger_command.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )

            self.arcade_mode = True
            logger.info("Arcade mode activated")
            return True

        except Exception as e:
            logger.error(f"Failed to enter arcade mode: {e}")
            return False

    def exit_arcade_mode(self) -> bool:
        """Exit arcade mode and return to clock display."""
        if not self.arcade_mode:
            return True

        try:
            if self.arcade_process and self.arcade_process.poll() is None:
                # Terminate the arcade process
                self.arcade_process.terminate()
                try:
                    self.arcade_process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    self.arcade_process.kill()
                    self.arcade_process.wait()

            self.arcade_mode = False
            self.arcade_process = None
            logger.info("Arcade mode deactivated")
            return True

        except Exception as e:
            logger.error(f"Failed to exit arcade mode: {e}")
            return False

    def is_arcade_active(self) -> bool:
        """Check if arcade mode is currently active."""
        if not self.arcade_mode:
            return False

        # Check if the arcade process is still running
        if self.arcade_process and self.arcade_process.poll() is not None:
            # Process has ended, exit arcade mode
            self.exit_arcade_mode()
            return False

        return True

    def _draw_clock_face(self) -> None:
        """Draw the clock face with hour markers."""
        # Draw outer circle
        for angle in range(360):
            rad = math.radians(angle)
            x = int(self.center_x + self.radius * math.cos(rad))
            y = int(self.center_y + self.radius * math.sin(rad))
            if 0 <= x < 128 and 0 <= y < 128:
                self.canvas.SetPixel(
                    x,
                    y,
                    self.clock_color.red,
                    self.clock_color.green,
                    self.clock_color.blue,
                )

        # Draw hour markers
        for hour in range(12):
            angle = hour * 30 - 90  # 30° per hour, starting at 12 o'clock
            rad = math.radians(angle)

            # Inner point of marker
            x1 = int(self.center_x + (self.radius - 5) * math.cos(rad))
            y1 = int(self.center_y + (self.radius - 5) * math.sin(rad))

            # Outer point of marker
            x2 = int(self.center_x + self.radius * math.cos(rad))
            y2 = int(self.center_y + self.radius * math.sin(rad))

            # Draw line for hour marker
            self._draw_line(x1, y1, x2, y2, 255, 255, 255)

    def _draw_hand(self, angle: float, length: float, thickness: int) -> None:
        """Draw a clock hand."""
        rad = math.radians(angle)
        end_x = int(self.center_x + length * math.cos(rad))
        end_y = int(self.center_y + length * math.sin(rad))

        # Draw hand with thickness
        for t in range(-thickness, thickness + 1):
            for t2 in range(-thickness, thickness + 1):
                if t * t + t2 * t2 <= thickness * thickness:
                    self._draw_line(
                        self.center_x + t,
                        self.center_y + t2,
                        end_x + t,
                        end_y + t2,
                        255,
                        255,
                        255,
                    )

    def _draw_line(
        self, x1: int, y1: int, x2: int, y2: int, r: int, g: int, b: int
    ) -> None:
        """Draw a line between two points."""
        dx = abs(x2 - x1)
        dy = abs(y2 - y1)
        sx = 1 if x1 < x2 else -1
        sy = 1 if y1 < y2 else -1
        err = dx - dy

        while True:
            if 0 <= x1 < 128 and 0 <= y1 < 128:
                self.canvas.SetPixel(x1, y1, r, g, b)

            if x1 == x2 and y1 == y2:
                break

            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                x1 += sx
            if e2 < dx:
                err += dx
                y1 += sy


class BecaTicker:
    """Main application class coordinating all display components."""

    def __init__(self):
        self.config = Config()
        self.calendar_manager = CalendarManager(self.config)

        # Initialize matrices
        self.matrix_chain1 = self._create_matrix("chain1")
        self.matrix_chain2 = self._create_matrix("chain2")

        # Initialize displays
        self.text_display = TextDisplay(
            self.matrix_chain1, self.config, self.calendar_manager
        )
        self.clock_display = ClockDisplay(self.matrix_chain2, self.config)

        # Threading
        self.running = False
        self.display_thread = None

        # Web interface
        self.app = Flask(__name__)
        self._setup_web_routes()

    def _create_matrix(self, chain_name: str) -> RGBMatrix:
        """Create and configure an RGB matrix for the specified chain."""
        options = RGBMatrixOptions()

        chain_config = self.config.get(f"matrix_options.{chain_name}", {})

        options.rows = chain_config.get("rows", 64)
        options.cols = chain_config.get("cols", 64)
        options.chain_length = chain_config.get("chain_length", 4)
        options.parallel = chain_config.get("parallel", 1)
        options.brightness = chain_config.get("brightness", 50)
        options.hardware_mapping = chain_config.get("hardware_mapping", "regular")
        options.gpio_slowdown = chain_config.get("gpio_slowdown", 4)
        options.drop_privileges = False

        return RGBMatrix(options=options)

    def _setup_web_routes(self) -> None:
        """Set up Flask web interface routes."""

        @self.app.route("/")
        def index():
            return render_template("index.html", config=self.config.config)

        @self.app.route("/api/config", methods=["GET"])
        def get_config():
            return jsonify(self.config.config)

        @self.app.route("/api/config", methods=["POST"])
        def update_config():
            try:
                new_config = request.json
                # Update specific configuration sections
                if "department_name" in new_config:
                    self.config.set("department_name", new_config["department_name"])
                if "scrolling_messages" in new_config:
                    self.config.set(
                        "scrolling_messages", new_config["scrolling_messages"]
                    )
                if "calendar_urls" in new_config:
                    self.config.set("calendar_urls", new_config["calendar_urls"])

                return jsonify(
                    {"status": "success", "message": "Configuration updated"}
                )
            except Exception as e:
                logger.error(f"Error updating config: {e}")
                return jsonify({"status": "error", "message": str(e)}), 500

        @self.app.route("/api/events")
        def get_events():
            events = self.calendar_manager.fetch_events()
            # Convert datetime objects to strings for JSON serialization
            serializable_events = []
            for event in events:
                serializable_event = event.copy()
                if isinstance(event["start"], datetime):
                    serializable_event["start"] = event["start"].isoformat()
                else:
                    serializable_event["start"] = event["start"].isoformat()
                if event["end"] and isinstance(event["end"], datetime):
                    serializable_event["end"] = event["end"].isoformat()
                serializable_events.append(serializable_event)
            return jsonify(serializable_events)

        @self.app.route("/api/arcade/start", methods=["POST"])
        def start_arcade():
            try:
                if self.clock_display.enter_arcade_mode():
                    return jsonify(
                        {"status": "success", "message": "Arcade mode started"}
                    )
                else:
                    return (
                        jsonify(
                            {
                                "status": "error",
                                "message": "Failed to start arcade mode",
                            }
                        ),
                        500,
                    )
            except Exception as e:
                logger.error(f"Error starting arcade mode: {e}")
                return jsonify({"status": "error", "message": str(e)}), 500

        @self.app.route("/api/arcade/stop", methods=["POST"])
        def stop_arcade():
            try:
                if self.clock_display.exit_arcade_mode():
                    return jsonify(
                        {"status": "success", "message": "Arcade mode stopped"}
                    )
                else:
                    return (
                        jsonify(
                            {"status": "error", "message": "Failed to stop arcade mode"}
                        ),
                        500,
                    )
            except Exception as e:
                logger.error(f"Error stopping arcade mode: {e}")
                return jsonify({"status": "error", "message": str(e)}), 500

        @self.app.route("/api/arcade/status")
        def arcade_status():
            return jsonify(
                {
                    "active": self.clock_display.is_arcade_active(),
                    "enabled": self.config.get("arcade_mode.enabled", False),
                }
            )

    def start(self) -> None:
        """Start the display system."""
        logger.info("Starting BecaTicker display system")
        self.running = True

        # Start display update thread
        self.display_thread = threading.Thread(target=self._display_loop, daemon=True)
        self.display_thread.start()

        # Start web interface
        web_port = self.config.get("web_port", 5000)
        logger.info(f"Starting web interface on port {web_port}")

        try:
            self.app.run(host="0.0.0.0", port=web_port, debug=False, threaded=True)
        except KeyboardInterrupt:
            self.stop()

    def stop(self) -> None:
        """Stop the display system."""
        logger.info("Stopping BecaTicker display system")
        self.running = False
        if self.display_thread:
            self.display_thread.join(timeout=2)

    def _display_loop(self) -> None:
        """Main display update loop."""
        logger.info("Display update loop started")

        while self.running:
            try:
                # Update displays
                self.text_display.update_display()
                self.clock_display.update_display()

                # Small delay to prevent excessive CPU usage
                time.sleep(0.1)

            except Exception as e:
                logger.error(f"Error in display loop: {e}")
                time.sleep(1)

        logger.info("Display update loop stopped")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="BecaTicker LED Matrix Display Controller"
    )
    parser.add_argument(
        "--config", default="config.json", help="Configuration file path"
    )
    parser.add_argument(
        "--log-level", default="INFO", choices=["DEBUG", "INFO", "WARNING", "ERROR"]
    )

    args = parser.parse_args()

    # Set log level
    logging.getLogger().setLevel(getattr(logging, args.log_level))

    try:
        # Create and start the ticker
        ticker = BecaTicker()
        ticker.start()

    except KeyboardInterrupt:
        logger.info("Received interrupt signal, shutting down")
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
