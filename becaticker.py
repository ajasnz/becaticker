#!/usr/bin/env python3
"""
BecaTicker - LED Matrix Display Controller

A dual-chain RGB LED matrix display system featuring:
- Chain 1: 4x1 horizontal panels (256x64) for text display
- Chain 2: 2x2 square panels (128x128) for analog clock and arcade games

Author: Generated by GitHub Copilot
Date: September 30, 2025
"""

import argparse
import hashlib
import json
import logging
import math
import os
import secrets
import subprocess
import sys
import threading
import time
from datetime import datetime, timedelta, timezone
from functools import wraps
from typing import Dict, List, Optional, Tuple

import requests
from dateutil import parser as date_parser
from flask import Flask, jsonify, render_template, request, session, redirect, url_for
from icalendar import Calendar
from PIL import Image, ImageDraw, ImageFont

# Add the RGB matrix library path
sys.path.append(
    os.path.join(os.path.dirname(__file__), "hzeller", "bindings", "python")
)

try:
    from rgbmatrix import RGBMatrix, RGBMatrixOptions, graphics
except ImportError as e:
    logger.error(f"Failed to import RGB matrix library: {e}")
    logger.error("Please ensure the RGB matrix library is properly installed.")
    logger.error("Run './build_rgb_matrix.sh' to build the library.")
    sys.exit(1)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler("becaticker.log"), logging.StreamHandler(sys.stdout)],
)
logger = logging.getLogger(__name__)


class Config:
    """Configuration manager for BecaTicker."""

    def __init__(self, config_file: str = "config.json"):
        self.config_file = config_file
        self.default_config = {
            "department_name": "SYSTEM ERROR",
            "scrolling_messages": [
                "Failed to load configuration file",
                "Try restarting the system",
                "Or visit http://becaticker.local:5000 to upload your own message",
            ],
            "calendar_urls": ["https://www.officeholidays.com/ics-all/new-zealand"],
            "web_port": 5000,
            "matrix_options": {
                "chain1": {
                    "rows": 64,
                    "cols": 64,
                    "chain_length": 2,
                    "parallel": 1,
                    "brightness": 75,
                    "gpio_mapping": "regular",
                },
                "chain2": {
                    "rows": 64,
                    "cols": 64,
                    "chain_length": 4,
                    "parallel": 1,
                    "brightness": 75,
                    "gpio_mapping": "regular",
                },
            },
            "display_settings": {
                "text_color": [255, 255, 255],
                "department_color": [0, 255, 255],
                "calendar_color": [255, 255, 0],
                "clock_color": [0, 255, 0],
                "background_color": [0, 0, 0],
                "scroll_speed": 0.1,
                "calendar_refresh_minutes": 30,
            },
            "display_lines": [],
            "arcade_mode": {
                "enabled": True,
                "trigger_command": "/usr/bin/emulationstation",
            },
        }
        self.config = self.load_config()

    def load_config(self) -> Dict:
        """Load configuration from file or create with defaults."""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, "r") as f:
                    config = json.load(f)
                # Merge with defaults to ensure all keys exist
                return {**self.default_config, **config}
            else:
                self.save_config(self.default_config)
                return self.default_config.copy()
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            return self.default_config.copy()

    def save_config(self, config: Dict = None) -> None:
        """Save configuration to file."""
        try:
            config_to_save = config or self.config
            with open(self.config_file, "w") as f:
                json.dump(config_to_save, f, indent=2)
            logger.info("Configuration saved successfully")
        except Exception as e:
            logger.error(f"Error saving config: {e}")

    def get(self, key: str, default=None):
        """Get configuration value."""
        keys = key.split(".")
        value = self.config
        for k in keys:
            value = value.get(k, {})
        return value if value != {} else default

    def set(self, key: str, value) -> None:
        """Set configuration value."""
        keys = key.split(".")
        config = self.config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value
        self.save_config()


class CalendarManager:
    """Manages calendar events from ICS feeds."""

    def __init__(self, config: Config):
        self.config = config
        self.events: List[Dict] = []
        self.last_update = datetime.min

    def fetch_events(self) -> List[Dict]:
        """Fetch and parse calendar events from ICS URLs."""
        calendar_urls = self.config.get("calendar_urls", [])
        if not calendar_urls:
            return []

        refresh_minutes = self.config.get(
            "display_settings.calendar_refresh_minutes", 30
        )
        if datetime.now() - self.last_update < timedelta(minutes=refresh_minutes):
            return self.events

        all_events = []

        for url in calendar_urls:
            try:
                logger.info(f"Fetching calendar from: {url}")
                response = requests.get(url, timeout=10)
                response.raise_for_status()

                cal = Calendar.from_ical(response.content)

                event_count = 0
                for component in cal.walk():
                    if component.name == "VEVENT":
                        event_count += 1
                        event = {
                            "summary": str(component.get("summary", "No Title")),
                            "start": component.get("dtstart").dt,
                            "end": (
                                component.get("dtend").dt
                                if component.get("dtend")
                                else None
                            ),
                            "description": str(component.get("description", "")),
                        }

                        logger.info(
                            f"Processing event: {event['summary']} at {event['start']}"
                        )

                        # Only include future events within next 7 days
                        if isinstance(event["start"], datetime):
                            start_time = event["start"]
                        else:
                            # Handle date-only events
                            start_time = datetime.combine(
                                event["start"], datetime.min.time()
                            )

                        # Normalize timezone handling
                        now = datetime.now()

                        # Convert both to naive datetime for comparison
                        if start_time.tzinfo is not None:
                            # Convert timezone-aware to local naive time
                            start_time = start_time.astimezone().replace(tzinfo=None)

                        # Ensure now is also naive (it should be by default)
                        if now.tzinfo is not None:
                            now = now.replace(tzinfo=None)

                        try:
                            # 7 day window
                            if start_time > now and start_time < now + timedelta(
                                days=7
                            ):
                                all_events.append(event)
                                logger.info(f"Added event: {event['summary']}")
                            else:
                                logger.info(
                                    f"Filtered out event: {event['summary']} (start: {start_time}, now: {now})"
                                )
                        except TypeError as te:
                            logger.warning(
                                f"Skipping event due to datetime comparison error: {te}"
                            )
                            continue

                logger.info(f"Processed {event_count} events from calendar")

            except Exception as e:
                logger.error(f"Error fetching calendar from {url}: {e}")

        # Sort events by start time
        all_events.sort(key=lambda x: x["start"])
        self.events = all_events[:30]  # Keep only next 30 events
        self.last_update = datetime.now()

        logger.info(f"Updated calendar with {len(self.events)} events")
        return self.events


class TextDisplay:
    """Handles text display on Chain 1 (4x1 horizontal panels)."""

    def __init__(
        self,
        matrix: RGBMatrix,
        config: Config,
        calendar_manager: CalendarManager,
        row_offset: int = 0,
    ):
        self.matrix = matrix
        self.config = config
        self.calendar_manager = calendar_manager
        self.canvas = None  # Will be set by main loop
        self.row_offset = row_offset  # For parallel chain support

        # Load fonts
        self.title_font = graphics.Font()
        self.title_font.LoadFont(os.path.join("hzeller", "fonts", "9x15B.bdf"))

        self.text_font = graphics.Font()
        self.text_font.LoadFont(os.path.join("hzeller", "fonts", "7x13.bdf"))

        self.small_font = graphics.Font()
        self.small_font.LoadFont(os.path.join("hzeller", "fonts", "6x10.bdf"))

        # Font cache for dynamic font loading
        self.font_cache = {}
        self._load_default_fonts()

        # Colors will be loaded dynamically in update_display()

        # Scrolling state
        self.scroll_pos = 0
        self.current_message_index = 0
        self.message_change_time = time.time()

        # Calendar scrolling state
        self.calendar_scroll_pos = 0
        self.current_event_index = 0
        self.event_change_time = time.time()

    def _load_default_fonts(self):
        """Pre-load commonly used fonts into cache."""
        default_fonts = [
            "4x6.bdf",
            "5x7.bdf",
            "5x8.bdf",
            "6x9.bdf",
            "6x10.bdf",
            "6x12.bdf",
            "7x13.bdf",
            "7x13B.bdf",
            "8x13.bdf",
            "8x13B.bdf",
            "9x15.bdf",
            "9x15B.bdf",
            "9x18.bdf",
            "9x18B.bdf",
            "10x20.bdf",
            "helvR12.bdf",
            "texgyre-27.bdf",
            "tom-thumb.bdf",
        ]

        for font_name in default_fonts:
            try:
                font_path = os.path.join("hzeller", "fonts", font_name)
                if os.path.exists(font_path):
                    font = graphics.Font()
                    font.LoadFont(font_path)
                    self.font_cache[font_name] = font
                    logger.debug(f"Loaded font: {font_name}")
            except Exception as e:
                logger.warning(f"Failed to load font {font_name}: {e}")

    def _get_font(self, font_name: str = None):
        """Get font object, loading it if necessary."""
        if not font_name or font_name == "default":
            return self.text_font

        if font_name in self.font_cache:
            return self.font_cache[font_name]

        # Try to load the font if not in cache
        try:
            font_path = os.path.join("hzeller", "fonts", font_name)
            if os.path.exists(font_path):
                font = graphics.Font()
                font.LoadFont(font_path)
                self.font_cache[font_name] = font
                logger.info(f"Dynamically loaded font: {font_name}")
                return font
        except Exception as e:
            logger.error(f"Failed to load font {font_name}: {e}")

        # Fall back to default font
        return self.text_font

    def _get_colors(self):
        """Get current colors from configuration."""
        text_color = self.config.get("display_settings.text_color", [255, 255, 255])
        dept_color = self.config.get("display_settings.department_color", [0, 255, 255])
        calendar_color = self.config.get(
            "display_settings.calendar_color", [255, 255, 0]
        )

        return {
            "text": graphics.Color(*text_color),
            "department": graphics.Color(*dept_color),
            "calendar": graphics.Color(*calendar_color),
        }

    def update_display(self) -> None:
        """Update the text display with current information."""
        if not self.canvas:
            return

        # Get current colors
        colors = self._get_colors()

        # Get configurable display lines
        display_lines = self.config.get("display_lines", [])

        # If no display lines configured, use default layout
        if not display_lines:
            # Default layout for backward compatibility
            dept_name = self.config.get("department_name", "DEPARTMENT")
            self._draw_centered_text(
                dept_name, self.title_font, colors["department"], 12
            )
            self._draw_scrolling_message(32, colors["text"])
            self._draw_calendar_events(52, colors["calendar"])
        else:
            # Use configurable display lines
            y_position = 12  # Start at top
            default_line_height = 20  # Default spacing between lines

            for line_config in display_lines:
                line_type = line_config.get("type", "disabled")
                line_content = line_config.get("content", "")
                line_spacing = line_config.get("spacing", default_line_height)
                line_scroll_speed = line_config.get("scroll_speed", None)
                line_bg_color = line_config.get("background_color", None)

                if line_type == "disabled":
                    continue

                # Calculate text Y position - center it within the background bar if present
                text_y_position = y_position
                if line_bg_color:
                    # Background bar spans from (y_position - 8) to (y_position - 8 + line_spacing)
                    # Center the text within this range
                    bar_start = y_position - 8
                    bar_height = line_spacing
                    text_y_position = (
                        bar_start + (bar_height // 2) + 4
                    )  # +4 for font baseline

                    self._draw_background_bar(bar_start, bar_height, line_bg_color)

                if line_type == "spacer":
                    # Spacer just adds space, no content
                    y_position += line_spacing
                    continue

                elif line_type == "department":
                    dept_name = self.config.get("department_name", "DEPARTMENT")
                    line_font = self._get_font(line_config.get("font"))
                    line_text_size = line_config.get("text_size", 1)
                    self._draw_centered_text(
                        dept_name,
                        line_font,
                        colors["department"],
                        text_y_position,
                        line_text_size,
                    )

                elif line_type == "message":
                    line_font = self._get_font(line_config.get("font"))
                    line_text_size = line_config.get("text_size", 1)
                    self._draw_scrolling_message(
                        text_y_position,
                        colors["text"],
                        line_scroll_speed,
                        line_font,
                        line_text_size,
                    )

                elif line_type == "calendar":
                    line_font = self._get_font(line_config.get("font"))
                    line_text_size = line_config.get("text_size", 1)
                    self._draw_calendar_events(
                        text_y_position,
                        colors["calendar"],
                        line_scroll_speed,
                        line_font,
                        line_text_size,
                    )

                elif line_type == "static":
                    if line_content:
                        line_font = self._get_font(line_config.get("font"))
                        line_text_size = line_config.get("text_size", 1)
                        self._draw_centered_text(
                            line_content,
                            line_font,
                            colors["text"],
                            text_y_position,
                            line_text_size,
                        )

                y_position += line_spacing

        # Note: Canvas swap is handled by main display loop

    def _draw_background_bar(self, y: int, height: int, color_rgb: List[int]) -> None:
        """Draw a full-width background color bar."""
        bg_color = graphics.Color(*color_rgb)
        # Apply row offset for parallel chain support
        y_adjusted = y + self.row_offset
        for row in range(
            max(self.row_offset, y_adjusted),
            min(self.row_offset + 64, y_adjusted + height),
        ):
            for col in range(self.canvas.width):
                self.canvas.SetPixel(
                    col, row, bg_color.red, bg_color.green, bg_color.blue
                )

    def _draw_centered_text(
        self,
        text: str,
        font: graphics.Font,
        color: graphics.Color,
        y: int,
        text_size: int = 1,
    ) -> None:
        """Draw centered text at specified y position with optional scaling."""
        if text_size > 1:
            # For scaled text, calculate width differently and draw multiple times
            char_width = font.CharacterWidth(ord("A"))  # Use average character width
            scaled_width = len(text) * char_width * text_size
            x = (self.canvas.width - scaled_width) // 2

            # Draw text with scaling by drawing multiple offset copies
            for scale_x in range(text_size):
                for scale_y in range(text_size):
                    graphics.DrawText(
                        self.canvas,
                        font,
                        x + scale_x,
                        y + scale_y + self.row_offset,
                        color,
                        text,
                    )
        else:
            text_width = sum([font.CharacterWidth(ord(c)) for c in text])
            x = (self.canvas.width - text_width) // 2
            graphics.DrawText(self.canvas, font, x, y + self.row_offset, color, text)

    def _draw_scrolling_message(
        self,
        y: int,
        color: graphics.Color = None,
        custom_scroll_speed: float = None,
        font: graphics.Font = None,
        text_size: int = 1,
    ) -> None:
        """Draw scrolling message at specified y position."""
        messages = self.config.get("scrolling_messages", ["No messages configured"])
        if not messages:
            return

        # Use provided color or default
        if color is None:
            text_color = self.config.get("display_settings.text_color", [255, 255, 255])
            color = graphics.Color(*text_color)

        # Use provided font or default
        if font is None:
            font = self.text_font

        current_message = messages[self.current_message_index]

        # Draw scrolling text with scaling support
        if text_size > 1:
            # Draw text with scaling by drawing multiple offset copies
            for scale_x in range(text_size):
                for scale_y in range(text_size):
                    text_len = graphics.DrawText(
                        self.canvas,
                        font,
                        self.scroll_pos + scale_x,
                        y + scale_y + self.row_offset,
                        color,
                        current_message,
                    )
        else:
            text_len = graphics.DrawText(
                self.canvas,
                font,
                self.scroll_pos,
                y + self.row_offset,
                color,
                current_message,
            )

        # Update scroll position - use custom speed if provided, otherwise use global setting
        if custom_scroll_speed is not None:
            scroll_speed = custom_scroll_speed
        else:
            scroll_speed = self.config.get("display_settings.scroll_speed", 0.1)
        self.scroll_pos -= int(scroll_speed * 10)  # Convert to pixel movement per frame

        # Change message when text completely scrolled off screen + 2 second pause
        if self.scroll_pos + text_len < 0:
            if time.time() - self.message_change_time > 2:  # 2 second pause
                self.current_message_index = (self.current_message_index + 1) % len(
                    messages
                )
                self.scroll_pos = self.canvas.width
                self.message_change_time = time.time()
            # Keep scroll position off-screen during pause
            elif self.scroll_pos + text_len < -10:
                self.scroll_pos = -text_len - 10

    def _draw_calendar_events(
        self,
        y: int,
        color: graphics.Color = None,
        custom_scroll_speed: float = None,
        font: graphics.Font = None,
        text_size: int = 1,
    ) -> None:
        """Draw scrolling calendar events."""
        events = self.calendar_manager.fetch_events()

        # Use provided color or default
        if color is None:
            calendar_color = self.config.get(
                "display_settings.calendar_color", [255, 255, 0]
            )
            color = graphics.Color(*calendar_color)

        # Use provided font or default
        if font is None:
            font = self.small_font

        if not events:
            if text_size > 1:
                # Draw "No upcoming events" with scaling
                for scale_x in range(text_size):
                    for scale_y in range(text_size):
                        graphics.DrawText(
                            self.canvas,
                            font,
                            2 + scale_x,
                            y + scale_y + self.row_offset,
                            color,
                            "No upcoming events",
                        )
            else:
                graphics.DrawText(
                    self.canvas,
                    font,
                    2,
                    y + self.row_offset,
                    color,
                    "No upcoming events",
                )
            return

        # Change event every 12 seconds
        if time.time() - self.event_change_time > 12:
            self.current_event_index = (self.current_event_index + 1) % len(events)
            self.event_change_time = time.time()
            self.calendar_scroll_pos = self.canvas.width

        current_event = events[self.current_event_index]

        # Format event text
        if isinstance(current_event["start"], datetime):
            start_str = current_event["start"].strftime("%m/%d %H:%M")
        else:
            start_str = current_event["start"].strftime("%m/%d")

        event_text = f"{start_str}: {current_event['summary']}"

        # Draw scrolling event text with scaling support
        if text_size > 1:
            # Draw text with scaling by drawing multiple offset copies
            for scale_x in range(text_size):
                for scale_y in range(text_size):
                    text_len = graphics.DrawText(
                        self.canvas,
                        font,
                        self.calendar_scroll_pos + scale_x,
                        y + scale_y + self.row_offset,
                        color,
                        event_text,
                    )
        else:
            text_len = graphics.DrawText(
                self.canvas,
                font,
                self.calendar_scroll_pos,
                y + self.row_offset,
                color,
                event_text,
            )

        # Update scroll position - use custom speed if provided, otherwise use global setting
        if custom_scroll_speed is not None:
            scroll_speed = custom_scroll_speed
        else:
            scroll_speed = self.config.get("display_settings.scroll_speed", 0.1)
        self.calendar_scroll_pos -= int(
            scroll_speed * 10
        )  # Convert to pixel movement per frame

        # Reset scroll when text completely off screen
        if self.calendar_scroll_pos + text_len < 0:
            self.calendar_scroll_pos = self.canvas.width


class ClockDisplay:
    """Handles analog clock display on Chain 2 (2x2 square panels)."""

    def __init__(self, matrix: RGBMatrix, config: Config, row_offset: int = 0):
        self.matrix = matrix
        self.config = config
        self.canvas = None  # Will be set by main loop
        self.row_offset = row_offset  # For parallel chain support

        # Clock settings
        clock_color = self.config.get("display_settings.clock_color", [0, 255, 0])
        self.clock_color = graphics.Color(*clock_color)
        self.center_x = 64  # Center of 128x128 display
        self.center_y = 32 + row_offset  # Adjust center for parallel chain
        self.radius = 30  # Smaller radius for 64-height constraint

        # Arcade mode
        self.arcade_mode = False
        self.arcade_process = None

    def update_display(self) -> None:
        """Update the analog clock display or show arcade mode."""
        if self.arcade_mode:
            # In arcade mode, the display is handled by the game system
            # Just keep the matrix clear for the game to use
            if self.canvas:
                self.canvas.Clear()
            return

        if not self.canvas:
            return

        now = datetime.now()

        # Draw clock face
        self._draw_clock_face()

        # Calculate angles (12 o'clock = 0°, clockwise)
        hour_angle = ((now.hour % 12) + now.minute / 60.0) * 30 - 90  # 30° per hour
        minute_angle = now.minute * 6 - 90  # 6° per minute
        second_angle = now.second * 6 - 90  # 6° per second

        # Draw hands
        self._draw_hand(hour_angle, self.radius * 0.5, 3)  # Hour hand
        self._draw_hand(minute_angle, self.radius * 0.8, 2)  # Minute hand
        self._draw_hand(second_angle, self.radius * 0.9, 1)  # Second hand

        # Draw center dot
        self.canvas.SetPixel(self.center_x, self.center_y, 255, 255, 255)

        # Note: Canvas swap is handled by main display loop

    def enter_arcade_mode(self) -> bool:
        """Enter arcade mode and launch RetroPie."""
        if self.arcade_mode:
            return True

        try:
            import subprocess

            trigger_command = self.config.get(
                "arcade_mode.trigger_command", "/usr/bin/emulationstation"
            )

            logger.info(f"Launching arcade mode: {trigger_command}")

            # Launch RetroPie/EmulationStation
            self.arcade_process = subprocess.Popen(
                trigger_command.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )

            self.arcade_mode = True
            logger.info("Arcade mode activated")
            return True

        except Exception as e:
            logger.error(f"Failed to enter arcade mode: {e}")
            return False

    def exit_arcade_mode(self) -> bool:
        """Exit arcade mode and return to clock display."""
        if not self.arcade_mode:
            return True

        try:
            if self.arcade_process and self.arcade_process.poll() is None:
                # Terminate the arcade process
                self.arcade_process.terminate()
                try:
                    self.arcade_process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    self.arcade_process.kill()
                    self.arcade_process.wait()

            self.arcade_mode = False
            self.arcade_process = None
            logger.info("Arcade mode deactivated")
            return True

        except Exception as e:
            logger.error(f"Failed to exit arcade mode: {e}")
            return False

    def is_arcade_active(self) -> bool:
        """Check if arcade mode is currently active."""
        if not self.arcade_mode:
            return False

        # Check if the arcade process is still running
        if self.arcade_process and self.arcade_process.poll() is not None:
            # Process has ended, exit arcade mode
            self.exit_arcade_mode()
            return False

        return True

    def _draw_clock_face(self) -> None:
        """Draw the clock face with hour markers."""
        # Draw outer circle
        for angle in range(360):
            rad = math.radians(angle)
            x = int(self.center_x + self.radius * math.cos(rad))
            y = int(self.center_y + self.radius * math.sin(rad))
            if (
                0 <= x < self.canvas.width
                and self.row_offset <= y < self.row_offset + 64
            ):
                self.canvas.SetPixel(
                    x,
                    y,
                    self.clock_color.red,
                    self.clock_color.green,
                    self.clock_color.blue,
                )

        # Draw hour markers
        for hour in range(12):
            angle = hour * 30 - 90  # 30° per hour, starting at 12 o'clock
            rad = math.radians(angle)

            # Inner point of marker
            x1 = int(self.center_x + (self.radius - 5) * math.cos(rad))
            y1 = int(self.center_y + (self.radius - 5) * math.sin(rad))

            # Outer point of marker
            x2 = int(self.center_x + self.radius * math.cos(rad))
            y2 = int(self.center_y + self.radius * math.sin(rad))

            # Draw line for hour marker
            self._draw_line(x1, y1, x2, y2, 255, 255, 255)

    def _draw_hand(self, angle: float, length: float, thickness: int) -> None:
        """Draw a clock hand."""
        rad = math.radians(angle)
        end_x = int(self.center_x + length * math.cos(rad))
        end_y = int(self.center_y + length * math.sin(rad))

        # Draw hand with thickness
        for t in range(-thickness, thickness + 1):
            for t2 in range(-thickness, thickness + 1):
                if t * t + t2 * t2 <= thickness * thickness:
                    self._draw_line(
                        self.center_x + t,
                        self.center_y + t2,
                        end_x + t,
                        end_y + t2,
                        255,
                        255,
                        255,
                    )

    def _draw_line(
        self, x1: int, y1: int, x2: int, y2: int, r: int, g: int, b: int
    ) -> None:
        """Draw a line between two points."""
        dx = abs(x2 - x1)
        dy = abs(y2 - y1)
        sx = 1 if x1 < x2 else -1
        sy = 1 if y1 < y2 else -1
        err = dx - dy

        while True:
            if (
                0 <= x1 < self.canvas.width
                and self.row_offset <= y1 < self.row_offset + 64
            ):
                self.canvas.SetPixel(x1, y1, r, g, b)

            if x1 == x2 and y1 == y2:
                break

            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                x1 += sx
            if e2 < dx:
                err += dx
                y1 += sy


class UserManager:
    """Manages user authentication with hashed passwords and JSON storage."""

    def __init__(self, db_file: str = "users.db"):
        self.db_file = db_file
        self.users = self.load_users()

    def load_users(self) -> Dict:
        """Load users from JSON file or create default admin user."""
        try:
            if os.path.exists(self.db_file):
                with open(self.db_file, "r") as f:
                    return json.load(f)
            else:
                # Create default admin user with hashed password
                default_users = {
                    "admin": {
                        "password_hash": self.hash_password("becaticker123"),
                        "role": "admin",
                        "created": datetime.now().isoformat(),
                        "last_login": None,
                        "active": True,
                    }
                }
                self.save_users(default_users)
                logger.info(
                    "Created default admin user (username: admin, password: becaticker123)"
                )
                return default_users
        except Exception as e:
            logger.error(f"Error loading users: {e}")
            return {}

    def save_users(self, users: Dict = None) -> None:
        """Save users to JSON file."""
        try:
            users_to_save = users or self.users
            with open(self.db_file, "w") as f:
                json.dump(users_to_save, f, indent=2)
            logger.info("Users database saved successfully")
        except Exception as e:
            logger.error(f"Error saving users: {e}")

    def hash_password(self, password: str) -> str:
        """Hash a password using SHA256 with salt."""
        salt = secrets.token_hex(16)
        password_hash = hashlib.sha256((password + salt).encode()).hexdigest()
        return f"{salt}:{password_hash}"

    def verify_password(self, password: str, password_hash: str) -> bool:
        """Verify a password against its hash."""
        try:
            salt, hash_part = password_hash.split(":")
            return hashlib.sha256((password + salt).encode()).hexdigest() == hash_part
        except ValueError:
            return False

    def authenticate_user(self, username: str, password: str) -> Optional[Dict]:
        """Authenticate a user and return user info if successful."""
        if username not in self.users:
            return None

        user = self.users[username]
        if not user.get("active", True):
            return None

        if self.verify_password(password, user["password_hash"]):
            # Update last login
            self.users[username]["last_login"] = datetime.now().isoformat()
            self.save_users()

            # Return user info without password hash
            user_info = user.copy()
            user_info.pop("password_hash", None)
            user_info["username"] = username
            return user_info

        return None

    def create_user(self, username: str, password: str, role: str = "user") -> bool:
        """Create a new user."""
        if username in self.users:
            return False

        self.users[username] = {
            "password_hash": self.hash_password(password),
            "role": role,
            "created": datetime.now().isoformat(),
            "last_login": None,
            "active": True,
        }
        self.save_users()
        logger.info(f"Created new user: {username}")
        return True

    def update_user_password(self, username: str, new_password: str) -> bool:
        """Update a user's password."""
        if username not in self.users:
            return False

        self.users[username]["password_hash"] = self.hash_password(new_password)
        self.save_users()
        logger.info(f"Updated password for user: {username}")
        return True

    def delete_user(self, username: str) -> bool:
        """Delete a user (mark as inactive)."""
        if username not in self.users or username == "admin":  # Protect admin user
            return False

        self.users[username]["active"] = False
        self.save_users()
        logger.info(f"Deactivated user: {username}")
        return True

    def list_users(self) -> List[Dict]:
        """List all active users (without password hashes)."""
        users = []
        for username, user_data in self.users.items():
            if user_data.get("active", True):
                user = user_data.copy()
                user["username"] = username
                user.pop("password_hash", None)
                users.append(user)
        return users

    def is_admin(self, username: str) -> bool:
        """Check if a user has admin role."""
        if username in self.users:
            return self.users[username].get("role") == "admin"
        return False


# Authentication Configuration
AUTH_CONFIG = {"enabled": True, "session_timeout": 3600}  # 1 hour in seconds


def login_required(f):
    """Decorator to require authentication for routes."""

    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not AUTH_CONFIG["enabled"]:
            return f(*args, **kwargs)

        if "authenticated" not in session or not session["authenticated"]:
            if request.is_json:
                return (
                    jsonify({"status": "error", "message": "Authentication required"}),
                    401,
                )
            return redirect(url_for("login"))

        # Check session timeout
        if "login_time" in session:
            login_time = session["login_time"]
            if time.time() - login_time > AUTH_CONFIG["session_timeout"]:
                session.clear()
                if request.is_json:
                    return (
                        jsonify({"status": "error", "message": "Session expired"}),
                        401,
                    )
                return redirect(url_for("login"))

        return f(*args, **kwargs)

    return decorated_function


class BecaTicker:
    """Main application class coordinating all display components."""

    def __init__(self):
        self.config = Config()
        self.user_manager = UserManager()
        self.calendar_manager = CalendarManager(self.config)

        # Initialize single matrix with parallel chains support
        # This will control both chains in parallel:
        # - Chain 1 (parallel=0): 4 text panels (rows 0-63)
        # - Chain 2 (parallel=1): clock panels (rows 64-127)
        self.matrix = self._create_matrix()

        # Initialize displays with different row offsets for parallel chains
        self.text_display = TextDisplay(
            self.matrix, self.config, self.calendar_manager, row_offset=0
        )
        self.clock_display = ClockDisplay(self.matrix, self.config, row_offset=64)

        # Threading
        self.running = False
        self.display_thread = None

        # Web interface
        self.app = Flask(__name__)
        self.app.secret_key = self.config.get("flask_secret_key", secrets.token_hex(32))
        self._setup_web_routes()

    def _create_matrix(self) -> RGBMatrix:
        """Create and configure an RGB matrix."""
        options = RGBMatrixOptions()

        chain_config = self.config.get("matrix_options", {})

        options.rows = chain_config.get("rows", 64)
        options.cols = chain_config.get("cols", 64)
        options.chain_length = chain_config.get("chain_length", 4)
        options.parallel = chain_config.get("parallel", 1)
        options.brightness = chain_config.get("brightness", 40)
        options.hardware_mapping = chain_config.get("hardware_mapping", "regular")
        options.gpio_slowdown = chain_config.get("gpio_slowdown", 2)
        options.drop_privileges = False
        options.disable_hardware_pulsing = True

        # Additional anti-flickering options for long chains
        if chain_config.get("chain_length", 1) >= 4:
            options.limit_refresh_rate_hz = 120  # Limit refresh rate for stability
            options.show_refresh_rate = False  # Don't show refresh rate counter

        return RGBMatrix(options=options)

    def _setup_web_routes(self) -> None:
        """Set up Flask web interface routes."""

        @self.app.route("/")
        @login_required
        def index():
            return render_template("index.html", config=self.config.config)

        @self.app.route("/api/config", methods=["GET"])
        @login_required
        def get_config():
            return jsonify(self.config.config)

        @self.app.route("/api/config", methods=["POST"])
        @login_required
        def update_config():
            try:
                new_config = request.json
                logger.info(f"Received config update: {new_config}")

                # Update specific configuration sections
                if "department_name" in new_config:
                    self.config.set("department_name", new_config["department_name"])
                if "scrolling_messages" in new_config:
                    self.config.set(
                        "scrolling_messages", new_config["scrolling_messages"]
                    )
                if "calendar_urls" in new_config:
                    self.config.set("calendar_urls", new_config["calendar_urls"])

                # Handle new display settings
                if "display_settings" in new_config:
                    display_settings = new_config["display_settings"]
                    for key, value in display_settings.items():
                        self.config.set(f"display_settings.{key}", value)
                        logger.info(
                            f"Updated display setting display_settings.{key}: {value}"
                        )

                # Handle display lines configuration
                if "display_lines" in new_config:
                    self.config.set("display_lines", new_config["display_lines"])
                    logger.info(f"Updated display lines: {new_config['display_lines']}")

                # Handle matrix options
                if "matrix_options" in new_config:
                    matrix_options = new_config["matrix_options"]
                    # Update brightness settings
                    if (
                        "chain1" in matrix_options
                        and "brightness" in matrix_options["chain1"]
                    ):
                        self.config.set(
                            "brightness", matrix_options["chain1"]["brightness"]
                        )
                        logger.info(
                            f"Updated brightness: {matrix_options['chain1']['brightness']}"
                        )
                    if (
                        "chain2" in matrix_options
                        and "brightness" in matrix_options["chain2"]
                    ):
                        # For now, use the same brightness for both chains
                        pass

                # Save the configuration to file
                self.config.save_config()
                logger.info("Configuration saved successfully")

                return jsonify(
                    {"status": "success", "message": "Configuration updated"}
                )
            except Exception as e:
                logger.error(f"Error updating config: {e}")
                return jsonify({"status": "error", "message": str(e)}), 500

        @self.app.route("/api/events")
        @login_required
        def get_events():
            events = self.calendar_manager.fetch_events()
            # Convert datetime objects to strings for JSON serialization
            serializable_events = []
            for event in events:
                serializable_event = event.copy()
                if isinstance(event["start"], datetime):
                    serializable_event["start"] = event["start"].isoformat()
                else:
                    serializable_event["start"] = event["start"].isoformat()
                if event["end"] and isinstance(event["end"], datetime):
                    serializable_event["end"] = event["end"].isoformat()
                serializable_events.append(serializable_event)
            return jsonify(serializable_events)

        @self.app.route("/api/arcade/start", methods=["POST"])
        @login_required
        def start_arcade():
            try:
                if self.clock_display and self.clock_display.enter_arcade_mode():
                    return jsonify(
                        {"status": "success", "message": "Arcade mode started"}
                    )
                else:
                    return (
                        jsonify(
                            {
                                "status": "error",
                                "message": "Failed to start arcade mode",
                            }
                        ),
                        500,
                    )
            except Exception as e:
                logger.error(f"Error starting arcade mode: {e}")
                return jsonify({"status": "error", "message": str(e)}), 500

        @self.app.route("/api/arcade/stop", methods=["POST"])
        @login_required
        def stop_arcade():
            try:
                if self.clock_display and self.clock_display.exit_arcade_mode():
                    return jsonify(
                        {"status": "success", "message": "Arcade mode stopped"}
                    )
                else:
                    return (
                        jsonify(
                            {
                                "status": "error",
                                "message": "Failed to stop arcade mode",
                            }
                        ),
                        500,
                    )
            except Exception as e:
                logger.error(f"Error stopping arcade mode: {e}")
                return jsonify({"status": "error", "message": str(e)}), 500

        @self.app.route("/api/arcade/status")
        @login_required
        def arcade_status():
            return jsonify(
                {
                    "active": (
                        self.clock_display.is_arcade_active()
                        if self.clock_display
                        else False
                    ),
                    "enabled": self.config.get("arcade_mode.enabled", False),
                }
            )

        # Authentication routes
        @self.app.route("/login", methods=["GET", "POST"])
        def login():
            if request.method == "POST":
                data = request.get_json() or request.form
                username = data.get("username", "").strip()
                password = data.get("password", "")

                user_info = self.user_manager.authenticate_user(username, password)
                if user_info:
                    session["authenticated"] = True
                    session["username"] = username
                    session["user_role"] = user_info["role"]
                    session["login_time"] = time.time()

                    if request.is_json:
                        return jsonify(
                            {"status": "success", "message": "Login successful"}
                        )
                    else:
                        return redirect("/")
                else:
                    if request.is_json:
                        return (
                            jsonify(
                                {"status": "error", "message": "Invalid credentials"}
                            ),
                            401,
                        )
                    else:
                        return render_template(
                            "login.html", error="Invalid username or password"
                        )

            return render_template("login.html")

        @self.app.route("/logout", methods=["GET", "POST"])
        def logout():
            session.clear()
            if request.is_json:
                return jsonify(
                    {"status": "success", "message": "Logged out successfully"}
                )
            else:
                return redirect("/login")

        @self.app.route("/api/auth/status")
        def auth_status():
            authenticated = session.get("authenticated", False)
            if authenticated and "login_time" in session:
                # Check if session has expired
                if time.time() - session["login_time"] > AUTH_CONFIG["session_timeout"]:
                    session.clear()
                    authenticated = False

            return jsonify(
                {
                    "authenticated": authenticated,
                    "username": session.get("username", ""),
                    "user_role": session.get("user_role", "user"),
                    "is_admin": session.get("user_role") == "admin",
                    "auth_enabled": AUTH_CONFIG["enabled"],
                }
            )

        # User management routes (admin only)
        @self.app.route("/api/users", methods=["GET"])
        @login_required
        def list_users():
            if session.get("user_role") != "admin":
                return (
                    jsonify({"status": "error", "message": "Admin access required"}),
                    403,
                )

            users = self.user_manager.list_users()
            return jsonify(users)

        @self.app.route("/api/users", methods=["POST"])
        @login_required
        def create_user():
            if session.get("user_role") != "admin":
                return (
                    jsonify({"status": "error", "message": "Admin access required"}),
                    403,
                )

            data = request.get_json()
            username = data.get("username", "").strip()
            password = data.get("password", "")
            role = data.get("role", "user")

            if not username or not password:
                return (
                    jsonify(
                        {"status": "error", "message": "Username and password required"}
                    ),
                    400,
                )

            if len(password) < 6:
                return (
                    jsonify(
                        {
                            "status": "error",
                            "message": "Password must be at least 6 characters",
                        }
                    ),
                    400,
                )

            if self.user_manager.create_user(username, password, role):
                return jsonify(
                    {
                        "status": "success",
                        "message": f"User '{username}' created successfully",
                    }
                )
            else:
                return (
                    jsonify({"status": "error", "message": "Username already exists"}),
                    400,
                )

        @self.app.route("/api/users/<username>", methods=["DELETE"])
        @login_required
        def delete_user(username):
            if session.get("user_role") != "admin":
                return (
                    jsonify({"status": "error", "message": "Admin access required"}),
                    403,
                )

            if username == "admin":
                return (
                    jsonify({"status": "error", "message": "Cannot delete admin user"}),
                    400,
                )

            if self.user_manager.delete_user(username):
                return jsonify(
                    {
                        "status": "success",
                        "message": f"User '{username}' deleted successfully",
                    }
                )
            else:
                return (
                    jsonify(
                        {
                            "status": "error",
                            "message": "User not found or cannot be deleted",
                        }
                    ),
                    400,
                )

        @self.app.route("/api/users/<username>/password", methods=["PUT"])
        @login_required
        def change_password(username):
            # Users can change their own password, admins can change any password
            current_user = session.get("username")
            is_admin = session.get("user_role") == "admin"

            if current_user != username and not is_admin:
                return jsonify({"status": "error", "message": "Unauthorized"}), 403

            data = request.get_json()
            new_password = data.get("new_password", "")

            if len(new_password) < 6:
                return (
                    jsonify(
                        {
                            "status": "error",
                            "message": "Password must be at least 6 characters",
                        }
                    ),
                    400,
                )

            if self.user_manager.update_user_password(username, new_password):
                return jsonify(
                    {"status": "success", "message": "Password updated successfully"}
                )
            else:
                return jsonify({"status": "error", "message": "User not found"}), 400

    def start(self) -> None:
        """Start the display system."""
        logger.info("Starting BecaTicker display system")
        self.running = True

        # Start display update thread
        self.display_thread = threading.Thread(target=self._display_loop, daemon=True)
        self.display_thread.start()

        # Start web interface
        web_port = self.config.get("web_port", 5000)
        logger.info(f"Starting web interface on port {web_port}")

        try:
            self.app.run(host="0.0.0.0", port=web_port, debug=False, threaded=True)
        except KeyboardInterrupt:
            self.stop()

    def stop(self) -> None:
        """Stop the display system."""
        logger.info("Stopping BecaTicker display system")
        self.running = False
        if self.display_thread:
            self.display_thread.join(timeout=2)

    def _display_loop(self) -> None:
        """Main display update loop."""
        logger.info("Display update loop started")

        # Create shared canvas for both displays
        canvas = self.matrix.CreateFrameCanvas()

        while self.running:
            try:
                # Clear the shared canvas
                canvas.Clear()

                # Set canvas for both displays
                self.text_display.canvas = canvas
                if self.clock_display:
                    self.clock_display.canvas = canvas

                # Update displays (they draw to the shared canvas)
                self.text_display.update_display()
                if self.clock_display:
                    self.clock_display.update_display()

                # Swap the canvas buffers once
                canvas = self.matrix.SwapOnVSync(canvas)

                # Small delay to prevent excessive CPU usage
                time.sleep(0.1)

            except Exception as e:
                logger.error(f"Error in display loop: {e}")
                time.sleep(1)

        logger.info("Display update loop stopped")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="BecaTicker LED Matrix Display Controller"
    )
    parser.add_argument(
        "--config", default="config.json", help="Configuration file path"
    )
    parser.add_argument(
        "--log-level", default="INFO", choices=["DEBUG", "INFO", "WARNING", "ERROR"]
    )

    args = parser.parse_args()

    # Set log level
    logging.getLogger().setLevel(getattr(logging, args.log_level))

    try:
        # Create and start the ticker
        ticker = BecaTicker()
        ticker.start()

    except KeyboardInterrupt:
        logger.info("Received interrupt signal, shutting down")
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
