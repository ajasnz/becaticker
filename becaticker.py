#!/usr/bin/env python3
"""
BecaTicker - LED Matrix Display Controller

A dual-instance RGB LED matrix display system featuring:
- Chain 1: 1x5 panels (320x64) for text display - separate matrix instance
- Chain 2: 2x2 panels (128x128) for analog clock display - separate matrix instance

Physical Layout:
Chain 1: [Text1][Text2][Text3][Text4][Text5]
Chain 2: [Clock-TL][Clock-TR]
         [Clock-BL][Clock-BR]

Each chain uses its own dedicated hzeller matrix instance with independent
canvases and coordinate systems. Chain 2 uses U-mapper for 2x2 layout.

Author: Generated by GitHub Copilot
Date: October 11, 2025
"""

import argparse
import hashlib
import json
import logging
import math
import os
import secrets
import sys
import threading
import time
from datetime import datetime, timedelta
from functools import wraps
from typing import Dict, List, Optional

import requests
from flask import Flask, jsonify, render_template, request, session, redirect, url_for
from icalendar import Calendar

# Configure logging first
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler("becaticker.log"), logging.StreamHandler(sys.stdout)],
)
logger = logging.getLogger(__name__)

# Add the RGB matrix library path
sys.path.append(
    os.path.join(os.path.dirname(__file__), "hzeller", "bindings", "python")
)

try:
    from rgbmatrix import RGBMatrix, RGBMatrixOptions, graphics
except ImportError as e:
    logger.error(f"Failed to import RGB matrix library: {e}")
    logger.error("Please ensure the RGB matrix library is properly installed.")
    logger.error("Run './build_rgb_matrix.sh' to build the library.")
    sys.exit(1)


class Config:
    """Configuration manager for BecaTicker."""

    def __init__(self, config_file: str = "config.json"):
        self.config_file = config_file
        self.default_config = {
            "department_name": "SYSTEM ERROR",
            "scrolling_messages": [
                "Failed to load configuration file",
                "Try restarting the system",
                "Or visit http://becaticker.local:5000 to upload your own message",
            ],
            "calendar_urls": ["https://www.officeholidays.com/ics-all/new-zealand"],
            "web_port": 5000,
            "matrix_options": {
                "chain1": {
                    "rows": 64,
                    "cols": 64,
                    "chain_length": 5,
                    "parallel": 1,
                    "brightness": 40,
                    "gpio_mapping": "regular",
                    "gpio_slowdown": 4,
                    "hardware_mapping": "regular",
                    "pixel_mapper_config": "",
                },
                "chain2": {
                    "rows": 64,
                    "cols": 64,
                    "chain_length": 2,
                    "parallel": 2,
                    "brightness": 40,
                    "gpio_mapping": "regular",
                    "gpio_slowdown": 4,
                    "hardware_mapping": "regular",
                    "pixel_mapper_config": "U-mapper",
                },
            },
            "display_settings": {
                "text_color": [255, 255, 255],
                "department_color": [0, 255, 255],
                "calendar_color": [255, 255, 0],
                "background_color": [0, 0, 0],
                "scroll_speed": 0.1,
                "calendar_refresh_minutes": 30,
            },
            "clock_settings": {
                "face_color": [64, 64, 64],
                "hour_hand_color": [255, 255, 255],
                "minute_hand_color": [255, 255, 0],
                "second_hand_color": [255, 0, 0],
                "number_color": [0, 255, 255],
                "tick_color": [128, 128, 128],
            },
            "display_lines": [],
        }
        self.config = self.load_config()

    def load_config(self) -> Dict:
        """Load configuration from file or create with defaults."""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, "r") as f:
                    config = json.load(f)
                # Merge with defaults to ensure all keys exist
                return {**self.default_config, **config}
            else:
                self.save_config(self.default_config)
                return self.default_config.copy()
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            return self.default_config.copy()

    def save_config(self, config: Dict = None) -> None:
        """Save configuration to file."""
        try:
            config_to_save = config or self.config
            with open(self.config_file, "w") as f:
                json.dump(config_to_save, f, indent=2)
            logger.info("Configuration saved successfully")
        except Exception as e:
            logger.error(f"Error saving config: {e}")

    def get(self, key: str, default=None):
        """Get configuration value."""
        keys = key.split(".")
        value = self.config
        for k in keys:
            value = value.get(k, {})
        return value if value != {} else default

    def set(self, key: str, value) -> None:
        """Set configuration value."""
        keys = key.split(".")
        config = self.config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value
        self.save_config()


class CalendarManager:
    """Manages calendar events from ICS feeds."""

    def __init__(self, config: Config):
        self.config = config
        self.events: List[Dict] = []
        self.last_update = datetime.min

    def fetch_events(self) -> List[Dict]:
        """Fetch and parse calendar events from ICS URLs."""
        calendar_urls = self.config.get("calendar_urls", [])
        if not calendar_urls:
            return []

        refresh_minutes = self.config.get(
            "display_settings.calendar_refresh_minutes", 30
        )
        if datetime.now() - self.last_update < timedelta(minutes=refresh_minutes):
            return self.events

        all_events = []

        for url in calendar_urls:
            try:
                logger.info(f"Fetching calendar from: {url}")
                response = requests.get(url, timeout=10)
                response.raise_for_status()

                cal = Calendar.from_ical(response.content)

                event_count = 0
                for component in cal.walk():
                    if component.name == "VEVENT":
                        event_count += 1
                        event = {
                            "summary": str(component.get("summary", "No Title")),
                            "start": component.get("dtstart").dt,
                            "end": (
                                component.get("dtend").dt
                                if component.get("dtend")
                                else None
                            ),
                            "description": str(component.get("description", "")),
                        }

                        logger.info(
                            f"Processing event: {event['summary']} at {event['start']}"
                        )

                        # Only include future events within next 7 days
                        if isinstance(event["start"], datetime):
                            start_time = event["start"]
                        else:
                            # Handle date-only events
                            start_time = datetime.combine(
                                event["start"], datetime.min.time()
                            )

                        # Normalize timezone handling
                        now = datetime.now()

                        # Convert both to naive datetime for comparison
                        if start_time.tzinfo is not None:
                            # Convert timezone-aware to local naive time
                            start_time = start_time.astimezone().replace(tzinfo=None)

                        # Ensure now is also naive (it should be by default)
                        if now.tzinfo is not None:
                            now = now.replace(tzinfo=None)

                        try:
                            # 7 day window
                            if start_time > now and start_time < now + timedelta(
                                days=7
                            ):
                                all_events.append(event)
                                logger.info(f"Added event: {event['summary']}")
                            else:
                                logger.info(
                                    f"Filtered out event: {event['summary']} (start: {start_time}, now: {now})"
                                )
                        except TypeError as te:
                            logger.warning(
                                f"Skipping event due to datetime comparison error: {te}"
                            )
                            continue

                logger.info(f"Processed {event_count} events from calendar")

            except Exception as e:
                logger.error(f"Error fetching calendar from {url}: {e}")

        # Sort events by start time
        all_events.sort(key=lambda x: x["start"])
        self.events = all_events[:30]  # Keep only next 30 events
        self.last_update = datetime.now()

        logger.info(f"Updated calendar with {len(self.events)} events")
        return self.events


class TextDisplay:
    """Handles text display on Chain 1 (5x1 horizontal panels)."""

    def __init__(
        self,
        matrix: RGBMatrix,
        config: Config,
        calendar_manager: CalendarManager,
        row_offset: int = 0,
    ):
        self.matrix = matrix
        self.config = config
        self.calendar_manager = calendar_manager
        self.canvas = None  # Will be set by main loop
        self.row_offset = row_offset  # For parallel chain support

        # Load fonts
        self.title_font = graphics.Font()
        self.title_font.LoadFont(os.path.join("hzeller", "fonts", "9x15B.bdf"))

        self.text_font = graphics.Font()
        self.text_font.LoadFont(os.path.join("hzeller", "fonts", "7x13.bdf"))

        self.small_font = graphics.Font()
        self.small_font.LoadFont(os.path.join("hzeller", "fonts", "6x10.bdf"))

        # Font cache for dynamic font loading
        self.font_cache = {}
        self._load_default_fonts()

        # Colors will be loaded dynamically in update_display()

        # Scrolling state
        self.scroll_pos = 0
        self.current_message_index = 0
        self.message_change_time = time.time()

        # Calendar scrolling state
        self.calendar_scroll_pos = 0
        self.current_event_index = 0
        self.event_change_time = time.time()

    def _load_default_fonts(self):
        """Pre-load commonly used fonts into cache."""
        default_fonts = [
            "4x6.bdf",
            "5x7.bdf",
            "5x8.bdf",
            "6x9.bdf",
            "6x10.bdf",
            "6x12.bdf",
            "7x13.bdf",
            "7x13B.bdf",
            "8x13.bdf",
            "8x13B.bdf",
            "9x15.bdf",
            "9x15B.bdf",
            "9x18.bdf",
            "9x18B.bdf",
            "10x20.bdf",
            "helvR12.bdf",
            "texgyre-27.bdf",
            "tom-thumb.bdf",
        ]

        for font_name in default_fonts:
            try:
                font_path = os.path.join("hzeller", "fonts", font_name)
                if os.path.exists(font_path):
                    font = graphics.Font()
                    font.LoadFont(font_path)
                    self.font_cache[font_name] = font
                    logger.debug(f"Loaded font: {font_name}")
            except Exception as e:
                logger.warning(f"Failed to load font {font_name}: {e}")

    def _get_font(self, font_name: str = None):
        """Get font object, loading it if necessary."""
        if not font_name or font_name == "default":
            return self.text_font

        if font_name in self.font_cache:
            return self.font_cache[font_name]

        # Try to load the font if not in cache
        try:
            font_path = os.path.join("hzeller", "fonts", font_name)
            if os.path.exists(font_path):
                font = graphics.Font()
                font.LoadFont(font_path)
                self.font_cache[font_name] = font
                logger.info(f"Dynamically loaded font: {font_name}")
                return font
        except Exception as e:
            logger.error(f"Failed to load font {font_name}: {e}")

        # Fall back to default font
        return self.text_font

    def _get_colors(self):
        """Get current colors from configuration."""
        text_color = self.config.get("display_settings.text_color", [255, 255, 255])
        dept_color = self.config.get("display_settings.department_color", [0, 255, 255])
        calendar_color = self.config.get(
            "display_settings.calendar_color", [255, 255, 0]
        )

        return {
            "text": graphics.Color(*text_color),
            "department": graphics.Color(*dept_color),
            "calendar": graphics.Color(*calendar_color),
        }

    def update_display(self) -> None:
        """Update the text display with current information."""
        if not self.canvas:
            return

        # Get current colors
        colors = self._get_colors()

        # Get configurable display lines
        display_lines = self.config.get("display_lines", [])

        # If no display lines configured, use default layout
        if not display_lines:
            # Default layout for backward compatibility
            dept_name = self.config.get("department_name", "DEPARTMENT")
            self._draw_centered_text(
                dept_name, self.title_font, colors["department"], 12
            )
            self._draw_scrolling_message(32, colors["text"])
            self._draw_calendar_events(52, colors["calendar"])
        else:
            # Use configurable display lines
            y_position = 12  # Start at top
            default_line_height = 20  # Default spacing between lines

            for line_config in display_lines:
                line_type = line_config.get("type", "disabled")
                line_content = line_config.get("content", "")
                line_spacing = line_config.get("spacing", default_line_height)
                line_scroll_speed = line_config.get("scroll_speed", None)
                line_bg_color = line_config.get("background_color", None)

                if line_type == "disabled":
                    continue

                # Calculate text Y position - center it within the background bar if present
                text_y_position = y_position
                if line_bg_color:
                    # Background bar spans from (y_position - 8) to (y_position - 8 + line_spacing)
                    # Center the text within this range
                    bar_start = y_position - 8
                    bar_height = line_spacing
                    text_y_position = (
                        bar_start + (bar_height // 2) + 4
                    )  # +4 for font baseline

                    self._draw_background_bar(bar_start, bar_height, line_bg_color)

                if line_type == "spacer":
                    # Spacer just adds space, no content
                    y_position += line_spacing
                    continue

                elif line_type == "department":
                    dept_name = self.config.get("department_name", "DEPARTMENT")
                    line_font = self._get_font(line_config.get("font"))
                    line_text_size = line_config.get("text_size", 1)
                    self._draw_centered_text(
                        dept_name,
                        line_font,
                        colors["department"],
                        text_y_position,
                        line_text_size,
                    )

                elif line_type == "message":
                    line_font = self._get_font(line_config.get("font"))
                    line_text_size = line_config.get("text_size", 1)
                    self._draw_scrolling_message(
                        text_y_position,
                        colors["text"],
                        line_scroll_speed,
                        line_font,
                        line_text_size,
                    )

                elif line_type == "calendar":
                    line_font = self._get_font(line_config.get("font"))
                    line_text_size = line_config.get("text_size", 1)
                    self._draw_calendar_events(
                        text_y_position,
                        colors["calendar"],
                        line_scroll_speed,
                        line_font,
                        line_text_size,
                    )

                elif line_type == "static":
                    if line_content:
                        line_font = self._get_font(line_config.get("font"))
                        line_text_size = line_config.get("text_size", 1)
                        self._draw_centered_text(
                            line_content,
                            line_font,
                            colors["text"],
                            text_y_position,
                            line_text_size,
                        )

                y_position += line_spacing

        # Note: Canvas swap is handled by main display loop

    def _draw_background_bar(self, y: int, height: int, color_rgb: List[int]) -> None:
        """Draw a full-width background color bar."""
        bg_color = graphics.Color(*color_rgb)
        # Apply row offset for parallel chain support
        y_adjusted = y + self.row_offset
        for row in range(
            max(self.row_offset, y_adjusted),
            min(self.row_offset + 64, y_adjusted + height),
        ):
            for col in range(self.canvas.width):
                self.canvas.SetPixel(
                    col, row, bg_color.red, bg_color.green, bg_color.blue
                )

    def _draw_centered_text(
        self,
        text: str,
        font: graphics.Font,
        color: graphics.Color,
        y: int,
        text_size: int = 1,
    ) -> None:
        """Draw centered text at specified y position with optional scaling."""
        if text_size > 1:
            # For scaled text, calculate width differently and draw multiple times
            char_width = font.CharacterWidth(ord("A"))  # Use average character width
            scaled_width = len(text) * char_width * text_size
            x = (self.canvas.width - scaled_width) // 2

            # Draw text with scaling by drawing multiple offset copies
            for scale_x in range(text_size):
                for scale_y in range(text_size):
                    graphics.DrawText(
                        self.canvas,
                        font,
                        x + scale_x,
                        y + scale_y + self.row_offset,
                        color,
                        text,
                    )
        else:
            text_width = sum([font.CharacterWidth(ord(c)) for c in text])
            x = (self.canvas.width - text_width) // 2
            graphics.DrawText(self.canvas, font, x, y + self.row_offset, color, text)

    def _draw_scrolling_message(
        self,
        y: int,
        color: graphics.Color = None,
        custom_scroll_speed: float = None,
        font: graphics.Font = None,
        text_size: int = 1,
    ) -> None:
        """Draw scrolling message at specified y position."""
        messages = self.config.get("scrolling_messages", ["No messages configured"])
        if not messages:
            return

        # Use provided color or default
        if color is None:
            text_color = self.config.get("display_settings.text_color", [255, 255, 255])
            color = graphics.Color(*text_color)

        # Use provided font or default
        if font is None:
            font = self.text_font

        current_message = messages[self.current_message_index]

        # Draw scrolling text with scaling support
        if text_size > 1:
            # Draw text with scaling by drawing multiple offset copies
            for scale_x in range(text_size):
                for scale_y in range(text_size):
                    text_len = graphics.DrawText(
                        self.canvas,
                        font,
                        self.scroll_pos + scale_x,
                        y + scale_y + self.row_offset,
                        color,
                        current_message,
                    )
        else:
            text_len = graphics.DrawText(
                self.canvas,
                font,
                self.scroll_pos,
                y + self.row_offset,
                color,
                current_message,
            )

        # Update scroll position - use custom speed if provided, otherwise use global setting
        if custom_scroll_speed is not None:
            scroll_speed = custom_scroll_speed
        else:
            scroll_speed = self.config.get("display_settings.scroll_speed", 0.1)
        self.scroll_pos -= int(scroll_speed * 10)  # Convert to pixel movement per frame

        # Change message when text completely scrolled off screen + 2 second pause
        if self.scroll_pos + text_len < 0:
            if time.time() - self.message_change_time > 2:  # 2 second pause
                self.current_message_index = (self.current_message_index + 1) % len(
                    messages
                )
                self.scroll_pos = self.canvas.width
                self.message_change_time = time.time()
            # Keep scroll position off-screen during pause
            elif self.scroll_pos + text_len < -10:
                self.scroll_pos = -text_len - 10

    def _draw_calendar_events(
        self,
        y: int,
        color: graphics.Color = None,
        custom_scroll_speed: float = None,
        font: graphics.Font = None,
        text_size: int = 1,
    ) -> None:
        """Draw scrolling calendar events."""
        events = self.calendar_manager.fetch_events()

        # Use provided color or default
        if color is None:
            calendar_color = self.config.get(
                "display_settings.calendar_color", [255, 255, 0]
            )
            color = graphics.Color(*calendar_color)

        # Use provided font or default
        if font is None:
            font = self.small_font

        if not events:
            if text_size > 1:
                # Draw "No upcoming events" with scaling
                for scale_x in range(text_size):
                    for scale_y in range(text_size):
                        graphics.DrawText(
                            self.canvas,
                            font,
                            2 + scale_x,
                            y + scale_y + self.row_offset,
                            color,
                            "No upcoming events",
                        )
            else:
                graphics.DrawText(
                    self.canvas,
                    font,
                    2,
                    y + self.row_offset,
                    color,
                    "No upcoming events",
                )
            return

        # Change event every 12 seconds
        if time.time() - self.event_change_time > 12:
            self.current_event_index = (self.current_event_index + 1) % len(events)
            self.event_change_time = time.time()
            self.calendar_scroll_pos = self.canvas.width

        current_event = events[self.current_event_index]

        # Format event text
        if isinstance(current_event["start"], datetime):
            start_str = current_event["start"].strftime("%m/%d %H:%M")
        else:
            start_str = current_event["start"].strftime("%m/%d")

        event_text = f"{start_str}: {current_event['summary']}"

        # Draw scrolling event text with scaling support
        if text_size > 1:
            # Draw text with scaling by drawing multiple offset copies
            for scale_x in range(text_size):
                for scale_y in range(text_size):
                    text_len = graphics.DrawText(
                        self.canvas,
                        font,
                        self.calendar_scroll_pos + scale_x,
                        y + scale_y + self.row_offset,
                        color,
                        event_text,
                    )
        else:
            text_len = graphics.DrawText(
                self.canvas,
                font,
                self.calendar_scroll_pos,
                y + self.row_offset,
                color,
                event_text,
            )

        # Update scroll position - use custom speed if provided, otherwise use global setting
        if custom_scroll_speed is not None:
            scroll_speed = custom_scroll_speed
        else:
            scroll_speed = self.config.get("display_settings.scroll_speed", 0.1)
        self.calendar_scroll_pos -= int(
            scroll_speed * 10
        )  # Convert to pixel movement per frame

        # Reset scroll when text completely off screen
        if self.calendar_scroll_pos + text_len < 0:
            self.calendar_scroll_pos = self.canvas.width


class AnalogClock:
    """Handles analog clock display on its own dedicated matrix instance."""

    def __init__(self, matrix: RGBMatrix, config: Config):
        self.matrix = matrix
        self.config = config
        self.canvas = None  # Will be set by main loop

        # Clock configuration - 2x2 panels = 128x128 total area
        # U-mapper handles the coordinate transformation automatically
        self.clock_width = 128
        self.clock_height = 128
        self.center_x = self.clock_width // 2  # 64 (center of 128px width)
        self.center_y = self.clock_height // 2  # 64 (center of 128px height)

        # Clock face parameters
        self.face_radius = min(self.center_x, self.center_y) - 5
        self.hour_hand_length = self.face_radius * 0.5
        self.minute_hand_length = self.face_radius * 0.7
        self.second_hand_length = self.face_radius * 0.9

        # Load colors from configuration
        self._load_colors()

    def _load_colors(self) -> None:
        """Load clock colors from configuration."""
        clock_settings = self.config.get("clock_settings", {})

        face_color = clock_settings.get("face_color", [64, 64, 64])
        hour_color = clock_settings.get("hour_hand_color", [255, 255, 255])
        minute_color = clock_settings.get("minute_hand_color", [255, 255, 0])
        second_color = clock_settings.get("second_hand_color", [255, 0, 0])
        number_color = clock_settings.get("number_color", [0, 255, 255])
        tick_color = clock_settings.get("tick_color", [128, 128, 128])

        self.face_color = graphics.Color(*face_color)
        self.hour_color = graphics.Color(*hour_color)
        self.minute_color = graphics.Color(*minute_color)
        self.second_color = graphics.Color(*second_color)
        self.number_color = graphics.Color(*number_color)
        self.tick_color = graphics.Color(*tick_color)

    def update_display(self) -> None:
        """Update the analog clock display."""
        if not self.canvas:
            return

        # Get current time
        now = datetime.now()
        hours = now.hour % 12  # Convert to 12-hour format
        minutes = now.minute
        seconds = now.second

        # Calculate angles (0 degrees = 12 o'clock, clockwise)
        # Subtract 90 degrees to start from 12 o'clock instead of 3 o'clock
        hour_angle = ((hours * 30) + (minutes * 0.5) - 90) * 3.14159 / 180
        minute_angle = ((minutes * 6) - 90) * 3.14159 / 180
        second_angle = ((seconds * 6) - 90) * 3.14159 / 180

        # Draw clock face
        self._draw_clock_face()

        # Draw hour markers
        self._draw_hour_markers()

        # Draw hands (in order: hour, minute, second)
        self._draw_hand(hour_angle, self.hour_hand_length, self.hour_color, thickness=3)
        self._draw_hand(
            minute_angle, self.minute_hand_length, self.minute_color, thickness=2
        )
        self._draw_hand(
            second_angle, self.second_hand_length, self.second_color, thickness=1
        )

        # Draw center dot
        self._draw_center_dot()

    def _draw_clock_face(self) -> None:
        """Draw the clock face circle."""
        self._draw_circle(
            self.center_x,
            self.center_y,
            self.face_radius,
            self.face_color,
            filled=False,
        )

    def _draw_hour_markers(self) -> None:
        """Draw hour markers (1-12) and minute tick marks."""
        # Draw 12 hour markers
        for hour in range(1, 13):
            angle = ((hour * 30) - 90) * 3.14159 / 180

            # Outer position for hour markers
            outer_x = self.center_x + int((self.face_radius - 10) * math.cos(angle))
            outer_y = self.center_y + int((self.face_radius - 10) * math.sin(angle))

            # Inner position for hour markers
            inner_x = self.center_x + int((self.face_radius - 20) * math.cos(angle))
            inner_y = self.center_y + int((self.face_radius - 20) * math.sin(angle))

            # Draw hour marker line
            self._draw_line(outer_x, outer_y, inner_x, inner_y, self.tick_color)

        # Draw 60 minute tick marks (smaller)
        for minute in range(0, 60, 5):  # Every 5 minutes
            if minute % 15 != 0:  # Skip hour positions
                angle = ((minute * 6) - 90) * 3.14159 / 180

                outer_x = self.center_x + int((self.face_radius - 5) * math.cos(angle))
                outer_y = self.center_y + int((self.face_radius - 5) * math.sin(angle))

                inner_x = self.center_x + int((self.face_radius - 10) * math.cos(angle))
                inner_y = self.center_y + int((self.face_radius - 10) * math.sin(angle))

                self._draw_line(outer_x, outer_y, inner_x, inner_y, self.tick_color)

    def _draw_hand(
        self, angle: float, length: float, color: graphics.Color, thickness: int = 1
    ) -> None:
        """Draw a clock hand."""
        end_x = self.center_x + int(length * math.cos(angle))
        end_y = self.center_y + int(length * math.sin(angle))

        # Draw multiple lines for thickness
        for dx in range(-thickness // 2, thickness // 2 + 1):
            for dy in range(-thickness // 2, thickness // 2 + 1):
                if dx * dx + dy * dy <= (thickness // 2) ** 2:  # Circle thickness
                    self._draw_line(
                        self.center_x + dx,
                        self.center_y + dy,
                        end_x + dx,
                        end_y + dy,
                        color,
                    )

    def _draw_center_dot(self) -> None:
        """Draw center dot."""
        self._draw_circle(self.center_x, self.center_y, 3, self.hour_color, filled=True)

    def _draw_circle(
        self, cx: int, cy: int, radius: int, color: graphics.Color, filled: bool = False
    ) -> None:
        """Draw a circle using Bresenham's circle algorithm."""
        if filled:
            for y in range(cy - radius, cy + radius + 1):
                for x in range(cx - radius, cx + radius + 1):
                    if (x - cx) ** 2 + (y - cy) ** 2 <= radius**2:
                        self._set_pixel(x, y, color)
        else:
            # Draw circle outline
            x = 0
            y = radius
            d = 3 - 2 * radius

            while y >= x:
                # Draw 8 octants
                self._set_pixel(cx + x, cy + y, color)
                self._set_pixel(cx - x, cy + y, color)
                self._set_pixel(cx + x, cy - y, color)
                self._set_pixel(cx - x, cy - y, color)
                self._set_pixel(cx + y, cy + x, color)
                self._set_pixel(cx - y, cy + x, color)
                self._set_pixel(cx + y, cy - x, color)
                self._set_pixel(cx - y, cy - x, color)

                x += 1
                if d > 0:
                    y -= 1
                    d = d + 4 * (x - y) + 10
                else:
                    d = d + 4 * x + 6

    def _draw_line(
        self, x0: int, y0: int, x1: int, y1: int, color: graphics.Color
    ) -> None:
        """Draw a line using Bresenham's line algorithm."""
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        x, y = x0, y0
        x_inc = 1 if x1 > x0 else -1
        y_inc = 1 if y1 > y0 else -1
        error = dx - dy

        while True:
            self._set_pixel(x, y, color)
            if x == x1 and y == y1:
                break
            if error > 0:
                x += x_inc
                error -= dy
            else:
                y += y_inc
                error += dx

    def _set_pixel(self, x: int, y: int, color: graphics.Color) -> None:
        """Set a pixel directly on the dedicated clock matrix."""
        # Direct pixel setting - no offsets needed since this is a dedicated matrix
        # U-mapper handles the 2x2 panel layout automatically
        if 0 <= x < self.clock_width and 0 <= y < self.clock_height and self.canvas:
            self.canvas.SetPixel(x, y, color.red, color.green, color.blue)


class UserManager:
    """Manages user authentication with hashed passwords and JSON storage."""

    def __init__(self, db_file: str = "users.db"):
        self.db_file = db_file
        self.users = self.load_users()

    def load_users(self) -> Dict:
        """Load users from JSON file or create default admin user."""
        try:
            if os.path.exists(self.db_file):
                with open(self.db_file, "r") as f:
                    return json.load(f)
            else:
                # Create default admin user with hashed password
                default_users = {
                    "admin": {
                        "password_hash": self.hash_password("becaticker123"),
                        "role": "admin",
                        "created": datetime.now().isoformat(),
                        "last_login": None,
                        "active": True,
                    }
                }
                self.save_users(default_users)
                logger.info(
                    "Created default admin user (username: admin, password: becaticker123)"
                )
                return default_users
        except Exception as e:
            logger.error(f"Error loading users: {e}")
            return {}

    def save_users(self, users: Dict = None) -> None:
        """Save users to JSON file."""
        try:
            users_to_save = users or self.users
            with open(self.db_file, "w") as f:
                json.dump(users_to_save, f, indent=2)
            logger.info("Users database saved successfully")
        except Exception as e:
            logger.error(f"Error saving users: {e}")

    def hash_password(self, password: str) -> str:
        """Hash a password using SHA256 with salt."""
        salt = secrets.token_hex(16)
        password_hash = hashlib.sha256((password + salt).encode()).hexdigest()
        return f"{salt}:{password_hash}"

    def verify_password(self, password: str, password_hash: str) -> bool:
        """Verify a password against its hash."""
        try:
            salt, hash_part = password_hash.split(":")
            return hashlib.sha256((password + salt).encode()).hexdigest() == hash_part
        except ValueError:
            return False

    def authenticate_user(self, username: str, password: str) -> Optional[Dict]:
        """Authenticate a user and return user info if successful."""
        if username not in self.users:
            return None

        user = self.users[username]
        if not user.get("active", True):
            return None

        if self.verify_password(password, user["password_hash"]):
            # Update last login
            self.users[username]["last_login"] = datetime.now().isoformat()
            self.save_users()

            # Return user info without password hash
            user_info = user.copy()
            user_info.pop("password_hash", None)
            user_info["username"] = username
            return user_info

        return None

    def create_user(self, username: str, password: str, role: str = "user") -> bool:
        """Create a new user."""
        if username in self.users:
            return False

        self.users[username] = {
            "password_hash": self.hash_password(password),
            "role": role,
            "created": datetime.now().isoformat(),
            "last_login": None,
            "active": True,
        }
        self.save_users()
        logger.info(f"Created new user: {username}")
        return True

    def update_user_password(self, username: str, new_password: str) -> bool:
        """Update a user's password."""
        if username not in self.users:
            return False

        self.users[username]["password_hash"] = self.hash_password(new_password)
        self.save_users()
        logger.info(f"Updated password for user: {username}")
        return True

    def delete_user(self, username: str) -> bool:
        """Delete a user (mark as inactive)."""
        if username not in self.users or username == "admin":  # Protect admin user
            return False

        self.users[username]["active"] = False
        self.save_users()
        logger.info(f"Deactivated user: {username}")
        return True

    def list_users(self) -> List[Dict]:
        """List all active users (without password hashes)."""
        users = []
        for username, user_data in self.users.items():
            if user_data.get("active", True):
                user = user_data.copy()
                user["username"] = username
                user.pop("password_hash", None)
                users.append(user)
        return users

    def is_admin(self, username: str) -> bool:
        """Check if a user has admin role."""
        if username in self.users:
            return self.users[username].get("role") == "admin"
        return False


# Authentication Configuration
AUTH_CONFIG = {"enabled": True, "session_timeout": 3600}  # 1 hour in seconds


def login_required(f):
    """Decorator to require authentication for routes."""

    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not AUTH_CONFIG["enabled"]:
            return f(*args, **kwargs)

        if "authenticated" not in session or not session["authenticated"]:
            if request.is_json:
                return (
                    jsonify({"status": "error", "message": "Authentication required"}),
                    401,
                )
            return redirect(url_for("login"))

        # Check session timeout
        if "login_time" in session:
            login_time = session["login_time"]
            if time.time() - login_time > AUTH_CONFIG["session_timeout"]:
                session.clear()
                if request.is_json:
                    return (
                        jsonify({"status": "error", "message": "Session expired"}),
                        401,
                    )
                return redirect(url_for("login"))

        return f(*args, **kwargs)

    return decorated_function


class BecaTicker:
    """Main application class coordinating all display components."""

    def __init__(self):
        self.config = Config()
        self.user_manager = UserManager()
        self.calendar_manager = CalendarManager(self.config)

        # Initialize separate matrix instances for each chain
        self.text_matrix = self._create_matrix("chain1")
        self.clock_matrix = self._create_matrix("chain2")

        # Initialize displays with their dedicated matrices
        # Chain 1: Text display (1x5 panels, 320x64)
        self.text_display = TextDisplay(
            self.text_matrix, self.config, self.calendar_manager, row_offset=0
        )

        # Chain 2: Analog clock display (2x2 panels, 128x128 with U-mapper)
        self.analog_clock = AnalogClock(self.clock_matrix, self.config)

        # Threading
        self.running = False
        self.display_thread = None

        # Web interface
        self.app = Flask(__name__)
        self.app.secret_key = self.config.get("flask_secret_key", secrets.token_hex(32))
        self._setup_web_routes()

    def _create_matrix(self, chain_name: str) -> RGBMatrix:
        """Create and configure a matrix instance for the specified chain."""
        options = RGBMatrixOptions()

        matrix_config = self.config.get("matrix_options", {})
        chain_config = matrix_config.get(chain_name, {})

        options.rows = chain_config.get("rows", 64)
        options.cols = chain_config.get("cols", 64)
        options.chain_length = chain_config.get("chain_length", 1)
        options.parallel = chain_config.get("parallel", 1)
        options.brightness = chain_config.get("brightness", 40)
        options.hardware_mapping = chain_config.get("hardware_mapping", "regular")
        options.gpio_slowdown = chain_config.get("gpio_slowdown", 2)

        # Set pixel mapper if specified
        pixel_mapper = chain_config.get("pixel_mapper_config", "")
        if pixel_mapper:
            options.pixel_mapper_config = pixel_mapper

        options.drop_privileges = False
        options.disable_hardware_pulsing = True

        # Additional anti-flickering options
        options.limit_refresh_rate_hz = 120  # Limit refresh rate for stability
        options.show_refresh_rate = False  # Don't show refresh rate counter

        logger.info(
            f"Creating {chain_name} matrix: {options.chain_length}x{options.parallel} "
            f"= {options.chain_length * options.cols}x{options.parallel * options.rows} pixels"
        )

        return RGBMatrix(options=options)

    def _setup_web_routes(self) -> None:
        """Set up Flask web interface routes."""

        @self.app.route("/")
        @login_required
        def index():
            return render_template("index.html", config=self.config.config)

        @self.app.route("/api/config", methods=["GET"])
        @login_required
        def get_config():
            return jsonify(self.config.config)

        @self.app.route("/api/config", methods=["POST"])
        @login_required
        def update_config():
            try:
                new_config = request.json
                logger.info(f"Received config update: {new_config}")

                # Update specific configuration sections
                if "department_name" in new_config:
                    self.config.set("department_name", new_config["department_name"])
                if "scrolling_messages" in new_config:
                    self.config.set(
                        "scrolling_messages", new_config["scrolling_messages"]
                    )
                if "calendar_urls" in new_config:
                    self.config.set("calendar_urls", new_config["calendar_urls"])

                # Handle new display settings
                if "display_settings" in new_config:
                    display_settings = new_config["display_settings"]
                    for key, value in display_settings.items():
                        self.config.set(f"display_settings.{key}", value)
                        logger.info(
                            f"Updated display setting display_settings.{key}: {value}"
                        )

                # Handle display lines configuration
                if "display_lines" in new_config:
                    self.config.set("display_lines", new_config["display_lines"])
                    logger.info(f"Updated display lines: {new_config['display_lines']}")

                # Handle matrix options
                if "matrix_options" in new_config:
                    matrix_options = new_config["matrix_options"]
                    # Update brightness settings
                    if (
                        "chain1" in matrix_options
                        and "brightness" in matrix_options["chain1"]
                    ):
                        self.config.set(
                            "brightness", matrix_options["chain1"]["brightness"]
                        )
                        logger.info(
                            f"Updated brightness: {matrix_options['chain1']['brightness']}"
                        )

                # Save the configuration to file
                self.config.save_config()
                logger.info("Configuration saved successfully")

                return jsonify(
                    {"status": "success", "message": "Configuration updated"}
                )
            except Exception as e:
                logger.error(f"Error updating config: {e}")
                return jsonify({"status": "error", "message": str(e)}), 500

        @self.app.route("/api/events")
        @login_required
        def get_events():
            events = self.calendar_manager.fetch_events()
            # Convert datetime objects to strings for JSON serialization
            serializable_events = []
            for event in events:
                serializable_event = event.copy()
                if isinstance(event["start"], datetime):
                    serializable_event["start"] = event["start"].isoformat()
                else:
                    serializable_event["start"] = event["start"].isoformat()
                if event["end"] and isinstance(event["end"], datetime):
                    serializable_event["end"] = event["end"].isoformat()
                serializable_events.append(serializable_event)
            return jsonify(serializable_events)

        # Authentication routes
        @self.app.route("/login", methods=["GET", "POST"])
        def login():
            if request.method == "POST":
                data = request.get_json() or request.form
                username = data.get("username", "").strip()
                password = data.get("password", "")

                user_info = self.user_manager.authenticate_user(username, password)
                if user_info:
                    session["authenticated"] = True
                    session["username"] = username
                    session["user_role"] = user_info["role"]
                    session["login_time"] = time.time()

                    if request.is_json:
                        return jsonify(
                            {"status": "success", "message": "Login successful"}
                        )
                    else:
                        return redirect("/")
                else:
                    if request.is_json:
                        return (
                            jsonify(
                                {"status": "error", "message": "Invalid credentials"}
                            ),
                            401,
                        )
                    else:
                        return render_template(
                            "login.html", error="Invalid username or password"
                        )

            return render_template("login.html")

        @self.app.route("/logout", methods=["GET", "POST"])
        def logout():
            session.clear()
            if request.is_json:
                return jsonify(
                    {"status": "success", "message": "Logged out successfully"}
                )
            else:
                return redirect("/login")

        @self.app.route("/api/auth/status")
        def auth_status():
            authenticated = session.get("authenticated", False)
            if authenticated and "login_time" in session:
                # Check if session has expired
                if time.time() - session["login_time"] > AUTH_CONFIG["session_timeout"]:
                    session.clear()
                    authenticated = False

            return jsonify(
                {
                    "authenticated": authenticated,
                    "username": session.get("username", ""),
                    "user_role": session.get("user_role", "user"),
                    "is_admin": session.get("user_role") == "admin",
                    "auth_enabled": AUTH_CONFIG["enabled"],
                }
            )

        # User management routes (admin only)
        @self.app.route("/api/users", methods=["GET"])
        @login_required
        def list_users():
            if session.get("user_role") != "admin":
                return (
                    jsonify({"status": "error", "message": "Admin access required"}),
                    403,
                )

            users = self.user_manager.list_users()
            return jsonify(users)

        @self.app.route("/api/users", methods=["POST"])
        @login_required
        def create_user():
            if session.get("user_role") != "admin":
                return (
                    jsonify({"status": "error", "message": "Admin access required"}),
                    403,
                )

            data = request.get_json()
            username = data.get("username", "").strip()
            password = data.get("password", "")
            role = data.get("role", "user")

            if not username or not password:
                return (
                    jsonify(
                        {"status": "error", "message": "Username and password required"}
                    ),
                    400,
                )

            if len(password) < 6:
                return (
                    jsonify(
                        {
                            "status": "error",
                            "message": "Password must be at least 6 characters",
                        }
                    ),
                    400,
                )

            if self.user_manager.create_user(username, password, role):
                return jsonify(
                    {
                        "status": "success",
                        "message": f"User '{username}' created successfully",
                    }
                )
            else:
                return (
                    jsonify({"status": "error", "message": "Username already exists"}),
                    400,
                )

        @self.app.route("/api/users/<username>", methods=["DELETE"])
        @login_required
        def delete_user(username):
            if session.get("user_role") != "admin":
                return (
                    jsonify({"status": "error", "message": "Admin access required"}),
                    403,
                )

            if username == "admin":
                return (
                    jsonify({"status": "error", "message": "Cannot delete admin user"}),
                    400,
                )

            if self.user_manager.delete_user(username):
                return jsonify(
                    {
                        "status": "success",
                        "message": f"User '{username}' deleted successfully",
                    }
                )
            else:
                return (
                    jsonify(
                        {
                            "status": "error",
                            "message": "User not found or cannot be deleted",
                        }
                    ),
                    400,
                )

        @self.app.route("/api/users/<username>/password", methods=["PUT"])
        @login_required
        def change_password(username):
            # Users can change their own password, admins can change any password
            current_user = session.get("username")
            is_admin = session.get("user_role") == "admin"

            if current_user != username and not is_admin:
                return jsonify({"status": "error", "message": "Unauthorized"}), 403

            data = request.get_json()
            new_password = data.get("new_password", "")

            if len(new_password) < 6:
                return (
                    jsonify(
                        {
                            "status": "error",
                            "message": "Password must be at least 6 characters",
                        }
                    ),
                    400,
                )

            if self.user_manager.update_user_password(username, new_password):
                return jsonify(
                    {"status": "success", "message": "Password updated successfully"}
                )
            else:
                return jsonify({"status": "error", "message": "User not found"}), 400

    def start(self) -> None:
        """Start the display system."""
        logger.info("Starting BecaTicker display system")
        self.running = True

        # Start display update thread
        self.display_thread = threading.Thread(target=self._display_loop, daemon=True)
        self.display_thread.start()

        # Start web interface
        web_port = self.config.get("web_port", 5000)
        logger.info(f"Starting web interface on port {web_port}")

        try:
            self.app.run(host="0.0.0.0", port=web_port, debug=False, threaded=True)
        except KeyboardInterrupt:
            self.stop()

    def stop(self) -> None:
        """Stop the display system."""
        logger.info("Stopping BecaTicker display system")
        self.running = False
        if self.display_thread:
            self.display_thread.join(timeout=2)

    def _display_loop(self) -> None:
        """Main display update loop for separate matrix instances."""
        logger.info("Display update loop started - separate matrix mode")

        # Create separate canvases for each display
        text_canvas = self.text_matrix.CreateFrameCanvas()
        clock_canvas = self.clock_matrix.CreateFrameCanvas()

        while self.running:
            try:
                # Clear both canvases
                text_canvas.Clear()
                clock_canvas.Clear()

                # Set canvases for each display
                self.text_display.canvas = text_canvas
                self.analog_clock.canvas = clock_canvas

                # Update both displays independently
                self.text_display.update_display()
                self.analog_clock.update_display()

                # Swap buffers for both matrices independently
                text_canvas = self.text_matrix.SwapOnVSync(text_canvas)
                clock_canvas = self.clock_matrix.SwapOnVSync(clock_canvas)

                # Small delay to prevent excessive CPU usage
                time.sleep(0.1)

            except Exception as e:
                logger.error(f"Error in display loop: {e}")
                time.sleep(1)

        logger.info("Display update loop stopped")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="BecaTicker LED Matrix Display Controller"
    )
    parser.add_argument(
        "--config", default="config.json", help="Configuration file path"
    )
    parser.add_argument(
        "--log-level", default="INFO", choices=["DEBUG", "INFO", "WARNING", "ERROR"]
    )

    args = parser.parse_args()

    # Set log level
    logging.getLogger().setLevel(getattr(logging, args.log_level))

    try:
        # Create and start the ticker
        ticker = BecaTicker()
        ticker.start()

    except KeyboardInterrupt:
        logger.info("Received interrupt signal, shutting down")
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
